{
  "schema_version": 1,
  "session_id": "49c7e506-a5b2-4c62-a1a8-16db44ab3acf",
  "transcript_path": "/Users/ia/.claude/projects/-Users-ia-Documents-code--orgs-my-entourage-entourage-web/49c7e506-a5b2-4c62-a1a8-16db44ab3acf.jsonl",
  "status": "complete",
  "start": {
    "timestamp": "2025-12-26T05:13:58Z",
    "cwd": "/Users/ia/Documents/code/@orgs/my-entourage/entourage-web",
    "source": "startup",
    "git": {
      "sha": "3d6ef2f475f4ec5f72054f1dcc7e4d53de4a9e35",
      "branch": "feat/design-system",
      "is_repo": true,
      "dirty": true,
      "dirty_files": [
        "package.json",
        "pnpm-lock.yaml",
        "src/app/globals.css",
        "src/app/page.tsx",
        "src/components/FlowDiagram.tsx",
        "src/components/Header.tsx",
        "src/components/Hero.tsx",
        "src/components/Logo.tsx",
        "src/components/SecondaryCTA.tsx",
        "src/components/ThemeToggle.tsx",
        "thoughts/plans/2025-12-25-vercel-style-design-language.md",
        ".claude/sessions/",
        ".claude/settings.json.backup.1766645162",
        ".claude/settings.json.backup.1766646959",
        ".claude/settings.json.backup.1766647068",
        ".claude/settings.json.backup.1766647313",
        ".claude/settings.json.backup.1766648820",
        "public/icons/",
        "public/logos/",
        "src/components/DataFolderSection.tsx",
        "src/components/FlowSection.tsx",
        "src/components/IntegrationsSection.tsx",
        "src/components/TeamCredentialsSection.tsx",
        "src/components/ui/Card.tsx",
        "src/components/ui/InfiniteSlider.tsx",
        "thoughts/shared/handoffs/general/",
        "thoughts/shared/plans/"
      ],
      "dirty_count": 27
    },
    "config": {
      "claude_md": "# Entourage Web - Development Guidelines\n\n## Project Overview\n\nEntourage is an AI-powered task management platform that extracts actionable items from meetings, chats, and communications. Built with Next.js 16, React 19, Tailwind CSS v4, and Framer Motion.\n\n## Design System\n\nRefer to `entourage_design_guide.md` for complete brand guidelines. Key principles:\n\n- **Digital Swiss Style**: Objectivity, precision, information density\n- **Typography**: Switzer (UI) + Geist Mono (code/data)\n- **Colors**: Functional only - black/white base, status colors for semantics\n- **Buttons**: Outline style preferred (black text, white background, border)\n- **Spacing**: 8px grid system\n\n## ShadCN UI Usage Guidelines\n\n### Core Principle: Never Modify ShadCN Components Directly\n\nWhen using ShadCN UI components:\n\n1. **Install with canary**: `pnpm dlx shadcn@canary add <component>` (required for Tailwind v4)\n2. **Components go to `src/components/ui/`** - This is the default ShadCN location\n3. **NEVER modify files in `src/components/ui/`** - Treat these as read-only primitives\n4. **Create wrapper components in `src/components/`** for any customization\n\n### Directory Structure\n\n```\nsrc/components/\n├── ui/                    # ShadCN primitives (DO NOT MODIFY)\n│   ├── button.tsx         # From: pnpm dlx shadcn@canary add button\n│   ├── card.tsx\n│   └── ...\n├── Button.tsx             # Custom wrapper around ui/button\n├── Header.tsx             # App components\n├── Hero.tsx\n└── ...\n```\n\n### Creating Wrapper Components (React 19)\n\nWhen you need custom behavior or styling, create a wrapper using React 19 patterns:\n\n```tsx\n// src/components/Button.tsx (Custom wrapper)\n// React 19: ref is a regular prop, no forwardRef needed\nimport { Button as ShadcnButton } from \"@/components/ui/button\";\nimport { cn } from \"@/lib/utils\";\nimport type { ComponentProps } from \"react\";\n\ntype ButtonProps = ComponentProps<typeof ShadcnButton>;\n\nexport function Button({ className, variant = \"outline\", ...props }: ButtonProps) {\n  return (\n    <ShadcnButton\n      variant={variant}\n      className={cn(\n        // Brand-aligned defaults\n        \"rounded-full\",\n        className\n      )}\n      {...props}\n    />\n  );\n}\n```\n\n**Note**: React 19 deprecated `forwardRef`. Use `ComponentProps` for type inference instead.\n\n### Styling Customization Methods\n\n1. **CSS Variables** - For global theme changes in `globals.css`\n2. **className prop** - For one-off customizations via `cn()` utility\n3. **Wrapper components** - For reusable patterns (preferred)\n\n### Why This Pattern?\n\n- ShadCN updates won't break your customizations\n- Clear separation between library code and your code\n- Easy to upgrade: `pnpm dlx shadcn@canary add [component] --overwrite`\n- Consistent patterns across the codebase\n\n### When NOT to Create Wrappers\n\nAvoid over-abstraction. Don't create wrappers that just pass props through:\n\n```tsx\n// WRONG - pointless wrapper\nexport function Card(props: CardProps) {\n  return <ShadcnCard {...props} />;\n}\n\n// CORRECT - wrapper adds brand value\nexport function Card({ className, ...props }: CardProps) {\n  return (\n    <ShadcnCard\n      className={cn(\"border-black shadow-none\", className)}\n      {...props}\n    />\n  );\n}\n```\n\n## Component Guidelines\n\n### Button Variants (per Design Guide)\n\n- **Primary/Outline**: Black text, white bg, black border (default)\n- **Ghost**: Transparent bg, text only, subtle hover\n- **Success**: Green text + border (for completed actions)\n\n### Animation Guidelines\n\n- Use `useReducedMotion` hook for accessibility\n- Animations should inform, not entertain\n- Hover states: instant\n- Toggle/switch: 120ms ease-in-out\n- Page transitions: 150ms ease-out\n\n## Code Style\n\n- Use TypeScript for all components\n- React 19: No `forwardRef` needed, ref is a regular prop\n- Always destructure props with defaults\n- Use `cn()` utility for className merging\n- Use `ComponentProps<typeof Component>` for type inference\n",
      "claude_md_path": "/Users/ia/Documents/code/@orgs/my-entourage/entourage-web/CLAUDE.md",
      "skills": {
        "add-shadcn-component": "---\nname: add-shadcn-component\ndescription: Add a new ShadCN UI component with proper wrapper pattern following Entourage brand guidelines. Use when installing ShadCN components like button, card, dialog, input, or any shadcn/ui component. Ensures components are never modified directly and wrappers are created for brand customization.\n---\n\n# Add ShadCN Component\n\nAdd a new ShadCN UI component with the proper wrapper pattern.\n\n## Usage\n\n```\n/add-shadcn-component <component-name>\n```\n\nExample: `/add-shadcn-component dialog`\n\n## Process\n\nWhen this skill is invoked, follow these steps:\n\n### Step 1: Install the ShadCN Component\n\nRun the shadcn CLI to add the component (use canary for Tailwind v4):\n\n```bash\npnpm dlx shadcn@canary add <component-name>\n```\n\nThis installs the component to `src/components/ui/<component-name>.tsx`.\n\n### Step 2: Verify Installation\n\nCheck that the component was created in the correct location:\n- Path: `src/components/ui/<component-name>.tsx`\n- The file should NOT be modified after installation\n\n### Step 3: Create Wrapper Component (if needed)\n\nDetermine if a wrapper is needed:\n- **YES** if: The component will be used directly in the app with brand-specific styling\n- **NO** if: The component is only used internally by other components (e.g., `alert-dialog` used by a custom `ConfirmButton`)\n- **NO** if: The wrapper would just pass props through without adding value (avoid over-wrapping)\n\nIf YES, create a wrapper in `src/components/` using React 19 patterns:\n\n```tsx\n// src/components/<ComponentName>.tsx\n// React 19: ref is a regular prop, no forwardRef needed\nimport { <ComponentName> as Shadcn<ComponentName> } from \"@/components/ui/<component-name>\";\nimport { cn } from \"@/lib/utils\";\nimport type { ComponentProps } from \"react\";\n\ntype <ComponentName>Props = ComponentProps<typeof Shadcn<ComponentName>>;\n\nexport function <ComponentName>({ className, ...props }: <ComponentName>Props) {\n  return (\n    <Shadcn<ComponentName>\n      className={cn(\n        // Brand-aligned defaults go here\n        className\n      )}\n      {...props}\n    />\n  );\n}\n```\n\n**Note**: This project uses React 19 which deprecated `forwardRef`. Use `ComponentProps` for type inference instead.\n\n### Step 4: Apply Brand Guidelines\n\nWhen creating the wrapper, apply these Entourage brand defaults:\n\n**Buttons:**\n- Use `variant=\"outline\"` as default\n- Add `rounded-full` class\n- Cursor pointer is handled by global CSS\n\n**Cards:**\n- White background\n- 1px black border (`border border-black`)\n- No shadows (`shadow-none`)\n- 16px padding (`p-4`)\n\n**Dialogs:**\n- Remove shadows\n- Black border\n- Minimal styling\n\n**Inputs:**\n- Black border on focus (`focus:border-black`)\n- No colored focus rings (`focus:ring-0`)\n\n**All Components:**\n- Follow 8px spacing grid\n- Use Switzer font (inherited from body)\n- Use Geist Mono for code/data displays\n- No decorative shadows or gradients\n\n### Step 5: Update Imports\n\nIf you created a wrapper, update any files that should use the wrapper:\n\n```tsx\n// Before (direct ShadCN import - only for internal use)\nimport { Button } from '@/components/ui/button';\n\n// After (wrapper import - for app-level use)\nimport { Button } from '@/components/Button';\n```\n\n### Step 6: Document\n\nAdd the new component to the migration checklist in `MIGRATION_PLAN.md` if applicable.\n\n## Important Rules\n\n1. **NEVER modify files in `src/components/ui/`** - These are ShadCN primitives\n2. **Always use `cn()` utility** for className merging in wrappers\n3. **Use React 19 patterns** - No forwardRef, use ComponentProps for types\n4. **Avoid over-wrapping** - Only create wrappers when adding brand value\n5. **Re-export types** from the wrapper if consumers need them\n\n## Quick Reference\n\n| ShadCN Component | Needs Wrapper? | Brand Customization |\n|------------------|----------------|---------------------|\n| button | Yes | Outline default, rounded-full |\n| card | Yes | Black border, no shadow |\n| input | Maybe | Black focus border |\n| dialog | Yes | No shadow, minimal styling |\n| dropdown-menu | Maybe | Black borders |\n| select | Maybe | Black borders |\n| toast | Yes | Status colors only |\n\n## Anti-Patterns to Avoid\n\n```tsx\n// WRONG: Wrapper that just passes props (no value added)\nexport function Card(props: CardProps) {\n  return <ShadcnCard {...props} />;\n}\n\n// WRONG: Using forwardRef (deprecated in React 19)\nexport const Button = forwardRef<HTMLButtonElement, ButtonProps>(\n  (props, ref) => <ShadcnButton ref={ref} {...props} />\n);\n\n// WRONG: Modifying ShadCN source files\n// Don't edit src/components/ui/button.tsx!\n\n// CORRECT: Wrapper with brand defaults\nexport function Button({ className, variant = \"outline\", ...props }: ButtonProps) {\n  return (\n    <ShadcnButton\n      variant={variant}\n      className={cn(\"rounded-full\", className)}\n      {...props}\n    />\n  );\n}\n```\n"
      },
      "commands": {
        "commit": "---\ndescription: Create git commits for session changes with clear, atomic messages\n---\n\n# Commit Changes\n\nYou are tasked with creating git commits for the changes made during this session.\n\n## Process:\n\n1. **Think about what changed:**\n\n    - Review the conversation history and understand what was accomplished\n    - Run `git status` to see current changes\n    - Run `git diff` to understand the modifications\n    - Consider whether changes should be one commit or multiple logical commits\n\n2. **Plan your commit(s):**\n\n    - Identify which files belong together\n    - Draft clear, descriptive commit messages\n    - Use prefixes on the commit messages; fix, refactor, feat, docs, style, test\n    - Use imperative mood in commit messages\n    - Focus on why the changes were made, not just what\n\n3. **Execute upon confirmation:**\n    - Use `git add` with specific files (never use `-A` or `.`)\n    - Never commit the `thoughts/` directory or anything inside it!\n    - Never commit dummy files, test scripts, or other files which you created or which appear to have been created but which were not part of your changes or directly caused by them (e.g. generated code)\n    - Create commits with your planned messages until all of your changes are committed with `git commit -m`\n\n## Remember:\n\n-   You have the full context of what was done in this session\n-   Group related changes together\n-   Keep commits focused and atomic when possible\n-   The user trusts your judgment - they asked you to commit\n-   **IMPORTANT**: - never stop and ask for feedback from the user.\n",
        "create_handoff": "---\ndescription: Create handoff document for transferring work to another session\n---\n\n# Create Handoff\n\nYou are tasked with writing a handoff document to hand off your work to another agent in a new session. You will create a handoff document that is thorough, but also **concise**. The goal is to compact and summarize your context without losing any of the key details of what you're working on.\n\n\n## Process\n### 1. Filepath & Metadata\nUse the following information to understand how to create your document:\n    - create your file under `thoughts/shared/handoffs/ENG-XXXX/YYYY-MM-DD_HH-MM-SS_ENG-ZZZZ_description.md`, where:\n        - YYYY-MM-DD is today's date\n        - HH-MM-SS is the hours, minutes and seconds based on the current time, in 24-hour format (i.e. use `13:00` for `1:00 pm`)\n        - ENG-XXXX is the ticket number (replace with `general` if no ticket)\n        - ENG-ZZZZ is the ticket number (omit if no ticket)\n        - description is a brief kebab-case description\n    - Run the `scripts/spec_metadata.sh` script to generate all relevant metadata\n    - Examples:\n        - With ticket: `2025-01-08_13-55-22_ENG-2166_create-context-compaction.md`\n        - Without ticket: `2025-01-08_13-55-22_create-context-compaction.md`\n\n### 2. Handoff writing.\nusing the above conventions, write your document. use the defined filepath, and the following YAML frontmatter pattern. Use the metadata gathered in step 1, Structure the document with YAML frontmatter followed by content:\n\nUse the following template structure:\n```markdown\n---\ndate: [Current date and time with timezone in ISO format]\nresearcher: [Researcher name from thoughts status]\ngit_commit: [Current commit hash]\nbranch: [Current branch name]\nrepository: [Repository name]\ntopic: \"[Feature/Task Name] Implementation Strategy\"\ntags: [implementation, strategy, relevant-component-names]\nstatus: complete\nlast_updated: [Current date in YYYY-MM-DD format]\nlast_updated_by: [Researcher name]\ntype: implementation_strategy\n---\n\n# Handoff: ENG-XXXX {very concise description}\n\n## Task(s)\n{description of the task(s) that you were working on, along with the status of each (completed, work in progress, planned/discussed). If you are working on an implementation plan, make sure to call out which phase you are on. Make sure to reference the plan document and/or research document(s) you are working from that were provided to you at the beginning of the session, if applicable.}\n\n## Critical References\n{List any critical specification documents, architectural decisions, or design docs that must be followed. Include only 2-3 most important file paths. Leave blank if none.}\n\n## Recent changes\n{describe recent changes made to the codebase that you made in line:file syntax}\n\n## Learnings\n{describe important things that you learned - e.g. patterns, root causes of bugs, or other important pieces of information someone that is picking up your work after you should know. consider listing explicit file paths.}\n\n## Artifacts\n{ an exhaustive list of artifacts you produced or updated as filepaths and/or file:line references - e.g. paths to feature documents, implementation plans, etc that should be read in order to resume your work.}\n\n## Action Items & Next Steps\n{ a list of action items and next steps for the next agent to accomplish based on your tasks and their statuses}\n\n## Other Notes\n{ other notes, references, or useful information - e.g. where relevant sections of the codebase are, where relevant documents are, or other important things you leanrned that you want to pass on but that don't fall into the above categories}\n```\n---\n\n### 3. Approve and Sync\nRun `humanlayer thoughts sync` to save the document.\n\nOnce this is completed, you should respond to the user with the template between <template_response></template_response> XML tags. do NOT include the tags in your response.\n\n<template_response>\nHandoff created and synced! You can resume from this handoff in a new session with the following command:\n\n```bash\n/resume_handoff path/to/handoff.md\n```\n</template_response>\n\nfor example (between <example_response></example_response> XML tags - do NOT include these tags in your actual response to the user)\n\n<example_response>\nHandoff created and synced! You can resume from this handoff in a new session with the following command:\n\n```bash\n/resume_handoff thoughts/shared/handoffs/ENG-2166/2025-01-08_13-44-55_ENG-2166_create-context-compaction.md\n```\n</example_response>\n\n---\n##.  Additional Notes & Instructions\n- **more information, not less**. This is a guideline that defines the minimum of what a handoff should be. Always feel free to include more information if necessary.\n- **be thorough and precise**. include both top-level objectives, and lower-level details as necessary.\n- **avoid excessive code snippets**. While a brief snippet to describe some key change is important, avoid large code blocks or diffs; do not include one unless it's necessary (e.g. pertains to an error you're debugging). Prefer using `/path/to/file.ext:line` references that an agent can follow later when it's ready, e.g. `packages/dashboard/src/app/dashboard/page.tsx:12-24`\n",
        "create_plan_no_thoughts": "---\ndescription: Create implementation plans with thorough research (no thoughts directory)\nmodel: opus\n---\n\n# Implementation Plan\n\nYou are tasked with creating detailed implementation plans through an interactive, iterative process. You should be skeptical, thorough, and work collaboratively with the user to produce high-quality technical specifications.\n\n## Initial Response\n\nWhen this command is invoked:\n\n1. **Check if parameters were provided**:\n   - If a file path or ticket reference was provided as a parameter, skip the default message\n   - Immediately read any provided files FULLY\n   - Begin the research process\n\n2. **If no parameters provided**, respond with:\n```\nI'll help you create a detailed implementation plan. Let me start by understanding what we're building.\n\nPlease provide:\n1. The task/ticket description (or reference to a ticket file)\n2. Any relevant context, constraints, or specific requirements\n3. Links to related research or previous implementations\n\nI'll analyze this information and work with you to create a comprehensive plan.\n\nTip: You can also invoke this command with a ticket file directly: `/create_plan thoughts/shared/tickets/eng_1234.md`\nFor deeper analysis, try: `/create_plan think deeply about thoughts/shared/tickets/eng_1234.md`\n```\n\nThen wait for the user's input.\n\n## Process Steps\n\n### Step 1: Context Gathering & Initial Analysis\n\n1. **Read all mentioned files immediately and FULLY**:\n   - Ticket files (e.g., `thoughts/shared/tickets/eng_1234.md`)\n   - Research documents\n   - Related implementation plans\n   - Any JSON/data files mentioned\n   - **IMPORTANT**: Use the Read tool WITHOUT limit/offset parameters to read entire files\n   - **CRITICAL**: DO NOT spawn sub-tasks before reading these files yourself in the main context\n   - **NEVER** read files partially - if a file is mentioned, read it completely\n\n2. **Spawn initial research tasks to gather context**:\n   Before asking the user any questions, use specialized agents to research in parallel:\n\n   - Use the **codebase-locator** agent to find all files related to the ticket/task\n   - Use the **codebase-analyzer** agent to understand how the current implementation works\n   - If a Linear ticket is mentioned, use the **linear-ticket-reader** agent to get full details\n\n   These agents will:\n   - Find relevant source files, configs, and tests\n   - Identify the specific directories to focus on (e.g., if WUI is mentioned, they'll focus on humanlayer-wui/)\n   - Trace data flow and key functions\n   - Return detailed explanations with file:line references\n\n3. **Read all files identified by research tasks**:\n   - After research tasks complete, read ALL files they identified as relevant\n   - Read them FULLY into the main context\n   - This ensures you have complete understanding before proceeding\n\n4. **Analyze and verify understanding**:\n   - Cross-reference the ticket requirements with actual code\n   - Identify any discrepancies or misunderstandings\n   - Note assumptions that need verification\n   - Determine true scope based on codebase reality\n\n5. **Present informed understanding and focused questions**:\n   ```\n   Based on the ticket and my research of the codebase, I understand we need to [accurate summary].\n\n   I've found that:\n   - [Current implementation detail with file:line reference]\n   - [Relevant pattern or constraint discovered]\n   - [Potential complexity or edge case identified]\n\n   Questions that my research couldn't answer:\n   - [Specific technical question that requires human judgment]\n   - [Business logic clarification]\n   - [Design preference that affects implementation]\n   ```\n\n   Only ask questions that you genuinely cannot answer through code investigation.\n\n### Step 2: Research & Discovery\n\nAfter getting initial clarifications:\n\n1. **If the user corrects any misunderstanding**:\n   - DO NOT just accept the correction\n   - Spawn new research tasks to verify the correct information\n   - Read the specific files/directories they mention\n   - Only proceed once you've verified the facts yourself\n\n2. **Create a research todo list** using TodoWrite to track exploration tasks\n\n3. **Spawn parallel sub-tasks for comprehensive research**:\n   - Create multiple Task agents to research different aspects concurrently\n   - Use the right agent for each type of research:\n\n   **For deeper investigation:**\n   - **codebase-locator** - To find more specific files (e.g., \"find all files that handle [specific component]\")\n   - **codebase-analyzer** - To understand implementation details (e.g., \"analyze how [system] works\")\n   - **codebase-pattern-finder** - To find similar features we can model after\n\n   **For related tickets:**\n   - **linear-searcher** - To find similar issues or past implementations\n\n   Each agent knows how to:\n   - Find the right files and code patterns\n   - Identify conventions and patterns to follow\n   - Look for integration points and dependencies\n   - Return specific file:line references\n   - Find tests and examples\n\n3. **Wait for ALL sub-tasks to complete** before proceeding\n\n4. **Present findings and design options**:\n   ```\n   Based on my research, here's what I found:\n\n   **Current State:**\n   - [Key discovery about existing code]\n   - [Pattern or convention to follow]\n\n   **Design Options:**\n   1. [Option A] - [pros/cons]\n   2. [Option B] - [pros/cons]\n\n   **Open Questions:**\n   - [Technical uncertainty]\n   - [Design decision needed]\n\n   Which approach aligns best with your vision?\n   ```\n\n### Step 3: Plan Structure Development\n\nOnce aligned on approach:\n\n1. **Create initial plan outline**:\n   ```\n   Here's my proposed plan structure:\n\n   ## Overview\n   [1-2 sentence summary]\n\n   ## Implementation Phases:\n   1. [Phase name] - [what it accomplishes]\n   2. [Phase name] - [what it accomplishes]\n   3. [Phase name] - [what it accomplishes]\n\n   Does this phasing make sense? Should I adjust the order or granularity?\n   ```\n\n2. **Get feedback on structure** before writing details\n\n### Step 4: Detailed Plan Writing\n\nAfter structure approval:\n\n1. **Write the plan** to `thoughts/shared/plans/YYYY-MM-DD-ENG-XXXX-description.md`\n   - Format: `YYYY-MM-DD-ENG-XXXX-description.md` where:\n     - YYYY-MM-DD is today's date\n     - ENG-XXXX is the ticket number (omit if no ticket)\n     - description is a brief kebab-case description\n   - Examples:\n     - With ticket: `2025-01-08-ENG-1478-parent-child-tracking.md`\n     - Without ticket: `2025-01-08-improve-error-handling.md`\n2. **Use this template structure**:\n\n````markdown\n# [Feature/Task Name] Implementation Plan\n\n## Overview\n\n[Brief description of what we're implementing and why]\n\n## Current State Analysis\n\n[What exists now, what's missing, key constraints discovered]\n\n## Desired End State\n\n[A Specification of the desired end state after this plan is complete, and how to verify it]\n\n### Key Discoveries:\n- [Important finding with file:line reference]\n- [Pattern to follow]\n- [Constraint to work within]\n\n## What We're NOT Doing\n\n[Explicitly list out-of-scope items to prevent scope creep]\n\n## Implementation Approach\n\n[High-level strategy and reasoning]\n\n## Phase 1: [Descriptive Name]\n\n### Overview\n[What this phase accomplishes]\n\n### Changes Required:\n\n#### 1. [Component/File Group]\n**File**: `path/to/file.ext`\n**Changes**: [Summary of changes]\n\n```[language]\n// Specific code to add/modify\n```\n\n### Success Criteria:\n\n#### Automated Verification:\n- [ ] Migration applies cleanly: `make migrate`\n- [ ] Unit tests pass: `make test-component`\n- [ ] Type checking passes: `npm run typecheck`\n- [ ] Linting passes: `make lint`\n- [ ] Integration tests pass: `make test-integration`\n\n#### Manual Verification:\n- [ ] Feature works as expected when tested via UI\n- [ ] Performance is acceptable under load\n- [ ] Edge case handling verified manually\n- [ ] No regressions in related features\n\n**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation from the human that the manual testing was successful before proceeding to the next phase.\n\n---\n\n## Phase 2: [Descriptive Name]\n\n[Similar structure with both automated and manual success criteria...]\n\n---\n\n## Testing Strategy\n\n### Unit Tests:\n- [What to test]\n- [Key edge cases]\n\n### Integration Tests:\n- [End-to-end scenarios]\n\n### Manual Testing Steps:\n1. [Specific step to verify feature]\n2. [Another verification step]\n3. [Edge case to test manually]\n\n## Performance Considerations\n\n[Any performance implications or optimizations needed]\n\n## Migration Notes\n\n[If applicable, how to handle existing data/systems]\n\n## References\n\n- Original ticket: `thoughts/shared/tickets/eng_XXXX.md`\n- Related research: `thoughts/shared/research/[relevant].md`\n- Similar implementation: `[file:line]`\n````\n\n### Step 5: Review\n\n1. **Present the draft plan location**:\n   ```\n   I've created the initial implementation plan at:\n   `thoughts/shared/plans/YYYY-MM-DD-ENG-XXXX-description.md`\n\n   Please review it and let me know:\n   - Are the phases properly scoped?\n   - Are the success criteria specific enough?\n   - Any technical details that need adjustment?\n   - Missing edge cases or considerations?\n   ```\n\n2. **Iterate based on feedback** - be ready to:\n   - Add missing phases\n   - Adjust technical approach\n   - Clarify success criteria (both automated and manual)\n   - Add/remove scope items\n\n3. **Continue refining** until the user is satisfied\n\n## Important Guidelines\n\n1. **Be Skeptical**:\n   - Question vague requirements\n   - Identify potential issues early\n   - Ask \"why\" and \"what about\"\n   - Don't assume - verify with code\n\n2. **Be Interactive**:\n   - Don't write the full plan in one shot\n   - Get buy-in at each major step\n   - Allow course corrections\n   - Work collaboratively\n\n3. **Be Thorough**:\n   - Read all context files COMPLETELY before planning\n   - Research actual code patterns using parallel sub-tasks\n   - Include specific file paths and line numbers\n   - Write measurable success criteria with clear automated vs manual distinction\n   - automated steps should use `make` whenever possible - for example `make -C humanlayer-wui check` instead of `cd humanlayer-wui && bun run fmt`\n\n4. **Be Practical**:\n   - Focus on incremental, testable changes\n   - Consider migration and rollback\n   - Think about edge cases\n   - Include \"what we're NOT doing\"\n\n5. **Track Progress**:\n   - Use TodoWrite to track planning tasks\n   - Update todos as you complete research\n   - Mark planning tasks complete when done\n\n6. **No Open Questions in Final Plan**:\n   - If you encounter open questions during planning, STOP\n   - Research or ask for clarification immediately\n   - Do NOT write the plan with unresolved questions\n   - The implementation plan must be complete and actionable\n   - Every decision must be made before finalizing the plan\n\n## Success Criteria Guidelines\n\n**Always separate success criteria into two categories:**\n\n1. **Automated Verification** (can be run by execution agents):\n   - Commands that can be run: `make test`, `npm run lint`, etc.\n   - Specific files that should exist\n   - Code compilation/type checking\n   - Automated test suites\n\n2. **Manual Verification** (requires human testing):\n   - UI/UX functionality\n   - Performance under real conditions\n   - Edge cases that are hard to automate\n   - User acceptance criteria\n\n**Format example:**\n```markdown\n### Success Criteria:\n\n#### Automated Verification:\n- [ ] Database migration runs successfully: `make migrate`\n- [ ] All unit tests pass: `go test ./...`\n- [ ] No linting errors: `golangci-lint run`\n- [ ] API endpoint returns 200: `curl localhost:8080/api/new-endpoint`\n\n#### Manual Verification:\n- [ ] New feature appears correctly in the UI\n- [ ] Performance is acceptable with 1000+ items\n- [ ] Error messages are user-friendly\n- [ ] Feature works correctly on mobile devices\n```\n\n## Common Patterns\n\n### For Database Changes:\n- Start with schema/migration\n- Add store methods\n- Update business logic\n- Expose via API\n- Update clients\n\n### For New Features:\n- Research existing patterns first\n- Start with data model\n- Build backend logic\n- Add API endpoints\n- Implement UI last\n\n### For Refactoring:\n- Document current behavior\n- Plan incremental changes\n- Maintain backwards compatibility\n- Include migration strategy\n\n## Sub-task Spawning Best Practices\n\nWhen spawning research sub-tasks:\n\n1. **Spawn multiple tasks in parallel** for efficiency\n2. **Each task should be focused** on a specific area\n3. **Provide detailed instructions** including:\n   - Exactly what to search for\n   - Which directories to focus on\n   - What information to extract\n   - Expected output format\n4. **Be EXTREMELY specific about directories**:\n   - If the ticket mentions \"WUI\", specify `humanlayer-wui/` directory\n   - If it mentions \"daemon\", specify `hld/` directory\n   - Never use generic terms like \"UI\" when you mean \"WUI\"\n   - Include the full path context in your prompts\n5. **Specify read-only tools** to use\n6. **Request specific file:line references** in responses\n7. **Wait for all tasks to complete** before synthesizing\n8. **Verify sub-task results**:\n   - If a sub-task returns unexpected results, spawn follow-up tasks\n   - Cross-check findings against the actual codebase\n   - Don't accept results that seem incorrect\n\nExample of spawning multiple tasks:\n```python\n# Spawn these tasks concurrently:\ntasks = [\n    Task(\"Research database schema\", db_research_prompt),\n    Task(\"Find API patterns\", api_research_prompt),\n    Task(\"Investigate UI components\", ui_research_prompt),\n    Task(\"Check test patterns\", test_research_prompt)\n]\n```\n\n## Example Interaction Flow\n\n```\nUser: /create_plan\nAssistant: I'll help you create a detailed implementation plan...\n\nUser: We need to add parent-child tracking for Claude sub-tasks. See thoughts/shared/tickets/eng_1478.md\nAssistant: Let me read that ticket file completely first...\n\n[Reads file fully]\n\nBased on the ticket, I understand we need to track parent-child relationships for Claude sub-task events in the hld daemon. Before I start planning, I have some questions...\n\n[Interactive process continues...]\n```\n",
        "create_plan": "---\ndescription: Create detailed implementation plans through interactive research and iteration\nmodel: opus\n---\n\n# Implementation Plan\n\nYou are tasked with creating detailed implementation plans through an interactive, iterative process. You should be skeptical, thorough, and work collaboratively with the user to produce high-quality technical specifications.\n\n## Initial Response\n\nWhen this command is invoked:\n\n1. **Check if parameters were provided**:\n\n    - If a file path or ticket reference was provided as a parameter, skip the default message\n    - Immediately read any provided files FULLY\n    - Begin the research process\n\n2. **If no parameters provided**, respond with:\n\n```\nI'll help you create a detailed implementation plan. Let me start by understanding what we're building.\n\nPlease provide:\n1. The task/ticket description (or reference to a ticket file)\n2. Any relevant context, constraints, or specific requirements\n3. Links to related research or previous implementations\n\nI'll analyze this information and work with you to create a comprehensive plan.\n\nTip: You can also invoke this command with a ticket file directly: `/create_plan thoughts/allison/tickets/eng_1234.md`\nFor deeper analysis, try: `/create_plan think deeply about thoughts/allison/tickets/eng_1234.md`\n```\n\nThen wait for the user's input.\n\n## Process Steps\n\n### Step 1: Context Gathering & Initial Analysis\n\n1. **Read all mentioned files immediately and FULLY**:\n\n    - Ticket files (e.g., `thoughts/allison/tickets/eng_1234.md`)\n    - Research documents\n    - Related implementation plans\n    - Any JSON/data files mentioned\n    - **IMPORTANT**: Use the Read tool WITHOUT limit/offset parameters to read entire files\n    - **CRITICAL**: DO NOT spawn sub-tasks before reading these files yourself in the main context\n    - **NEVER** read files partially - if a file is mentioned, read it completely\n\n2. **Spawn initial research tasks to gather context**: Before asking the user any questions, use specialized agents to research in parallel:\n\n    - Use the **codebase-locator** agent to find all files related to the ticket/task\n    - Use the **codebase-analyzer** agent to understand how the current implementation works\n    - If relevant, use the **thoughts-locator** agent to find any existing thoughts documents about this feature\n    - If a Linear ticket is mentioned, use the **linear-ticket-reader** agent to get full details\n\n    These agents will:\n\n    - Find relevant source files, configs, and tests\n    - Identify the specific directories to focus on (e.g., if WUI is mentioned, they'll focus on humanlayer-wui/)\n    - Trace data flow and key functions\n    - Return detailed explanations with file:line references\n\n3. **Read all files identified by research tasks**:\n\n    - After research tasks complete, read ALL files they identified as relevant\n    - Read them FULLY into the main context\n    - This ensures you have complete understanding before proceeding\n\n4. **Analyze and verify understanding**:\n\n    - Cross-reference the ticket requirements with actual code\n    - Identify any discrepancies or misunderstandings\n    - Note assumptions that need verification\n    - Determine true scope based on codebase reality\n\n5. **Present informed understanding and focused questions**:\n\n    ```\n    Based on the ticket and my research of the codebase, I understand we need to [accurate summary].\n\n    I've found that:\n    - [Current implementation detail with file:line reference]\n    - [Relevant pattern or constraint discovered]\n    - [Potential complexity or edge case identified]\n\n    Questions that my research couldn't answer:\n    - [Specific technical question that requires human judgment]\n    - [Business logic clarification]\n    - [Design preference that affects implementation]\n    ```\n\n    Only ask questions that you genuinely cannot answer through code investigation.\n\n### Step 2: Research & Discovery\n\nAfter getting initial clarifications:\n\n1. **If the user corrects any misunderstanding**:\n\n    - DO NOT just accept the correction\n    - Spawn new research tasks to verify the correct information\n    - Read the specific files/directories they mention\n    - Only proceed once you've verified the facts yourself\n\n2. **Create a research todo list** using TodoWrite to track exploration tasks\n\n3. **Spawn parallel sub-tasks for comprehensive research**:\n\n    - Create multiple Task agents to research different aspects concurrently\n    - Use the right agent for each type of research:\n\n    **For deeper investigation:**\n\n    - **codebase-locator** - To find more specific files (e.g., \"find all files that handle [specific component]\")\n    - **codebase-analyzer** - To understand implementation details (e.g., \"analyze how [system] works\")\n    - **codebase-pattern-finder** - To find similar features we can model after\n\n    **For historical context:**\n\n    - **thoughts-locator** - To find any research, plans, or decisions about this area\n    - **thoughts-analyzer** - To extract key insights from the most relevant documents\n\n    **For related tickets:**\n\n    - **linear-searcher** - To find similar issues or past implementations\n\n    Each agent knows how to:\n\n    - Find the right files and code patterns\n    - Identify conventions and patterns to follow\n    - Look for integration points and dependencies\n    - Return specific file:line references\n    - Find tests and examples\n\n4. **Wait for ALL sub-tasks to complete** before proceeding\n\n5. **Present findings and design options**:\n\n    ```\n    Based on my research, here's what I found:\n\n    **Current State:**\n    - [Key discovery about existing code]\n    - [Pattern or convention to follow]\n\n    **Design Options:**\n    1. [Option A] - [pros/cons]\n    2. [Option B] - [pros/cons]\n\n    **Open Questions:**\n    - [Technical uncertainty]\n    - [Design decision needed]\n\n    Which approach aligns best with your vision?\n    ```\n\n### Step 3: Plan Structure Development\n\nOnce aligned on approach:\n\n1. **Create initial plan outline**:\n\n    ```\n    Here's my proposed plan structure:\n\n    ## Overview\n    [1-2 sentence summary]\n\n    ## Implementation Phases:\n    1. [Phase name] - [what it accomplishes]\n    2. [Phase name] - [what it accomplishes]\n    3. [Phase name] - [what it accomplishes]\n\n    Does this phasing make sense? Should I adjust the order or granularity?\n    ```\n\n2. **Get feedback on structure** before writing details\n\n### Step 4: Detailed Plan Writing\n\nAfter structure approval:\n\n1. **Write the plan** to `thoughts/shared/plans/YYYY-MM-DD-ENG-XXXX-description.md`\n    - Format: `YYYY-MM-DD-ENG-XXXX-description.md` where:\n        - YYYY-MM-DD is today's date\n        - ENG-XXXX is the ticket number (omit if no ticket)\n        - description is a brief kebab-case description\n    - Examples:\n        - With ticket: `2025-01-08-ENG-1478-parent-child-tracking.md`\n        - Without ticket: `2025-01-08-improve-error-handling.md`\n2. **Use this template structure**:\n\n````markdown\n# [Feature/Task Name] Implementation Plan\n\n## Overview\n\n[Brief description of what we're implementing and why]\n\n## Current State Analysis\n\n[What exists now, what's missing, key constraints discovered]\n\n## Desired End State\n\n[A Specification of the desired end state after this plan is complete, and how to verify it]\n\n### Key Discoveries:\n\n-   [Important finding with file:line reference]\n-   [Pattern to follow]\n-   [Constraint to work within]\n\n## What We're NOT Doing\n\n[Explicitly list out-of-scope items to prevent scope creep]\n\n## Implementation Approach\n\n[High-level strategy and reasoning]\n\n## Phase 1: [Descriptive Name]\n\n### Overview\n\n[What this phase accomplishes]\n\n### Changes Required:\n\n#### 1. [Component/File Group]\n\n**File**: `path/to/file.ext` **Changes**: [Summary of changes]\n\n```[language]\n// Specific code to add/modify\n```\n\n### Success Criteria:\n\n#### Automated Verification:\n\n-   [ ] Migration applies cleanly: `make migrate`\n-   [ ] Unit tests pass: `make test-component`\n-   [ ] Type checking passes: `npm run typecheck`\n-   [ ] Linting passes: `make lint`\n-   [ ] Integration tests pass: `make test-integration`\n\n#### Manual Verification:\n\n-   [ ] Feature works as expected when tested via UI\n-   [ ] Performance is acceptable under load\n-   [ ] Edge case handling verified manually\n-   [ ] No regressions in related features\n\n**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation from the human that the manual testing was successful before proceeding to the next phase.\n\n---\n\n## Phase 2: [Descriptive Name]\n\n[Similar structure with both automated and manual success criteria...]\n\n---\n\n## Testing Strategy\n\n### Unit Tests:\n\n-   [What to test]\n-   [Key edge cases]\n\n### Integration Tests:\n\n-   [End-to-end scenarios]\n\n### Manual Testing Steps:\n\n1. [Specific step to verify feature]\n2. [Another verification step]\n3. [Edge case to test manually]\n\n## Performance Considerations\n\n[Any performance implications or optimizations needed]\n\n## Migration Notes\n\n[If applicable, how to handle existing data/systems]\n\n## References\n\n-   Original ticket: `thoughts/allison/tickets/eng_XXXX.md`\n-   Related research: `thoughts/shared/research/[relevant].md`\n-   Similar implementation: `[file:line]`\n````\n\n### Step 5: Sync and Review\n\n1. **Sync the thoughts directory**:\n\n    - Run `humanlayer thoughts sync` to sync the newly created plan\n    - This ensures the plan is properly indexed and available\n\n2. **Present the draft plan location**:\n\n    ```\n    I've created the initial implementation plan at:\n    `thoughts/shared/plans/YYYY-MM-DD-ENG-XXXX-description.md`\n\n    Please review it and let me know:\n    - Are the phases properly scoped?\n    - Are the success criteria specific enough?\n    - Any technical details that need adjustment?\n    - Missing edge cases or considerations?\n    ```\n\n3. **Iterate based on feedback** - be ready to:\n\n    - Add missing phases\n    - Adjust technical approach\n    - Clarify success criteria (both automated and manual)\n    - Add/remove scope items\n    - After making changes, run `humanlayer thoughts sync` again\n\n4. **Continue refining** until the user is satisfied\n\n## Important Guidelines\n\n1. **Be Skeptical**:\n\n    - Question vague requirements\n    - Identify potential issues early\n    - Ask \"why\" and \"what about\"\n    - Don't assume - verify with code\n\n2. **Be Interactive**:\n\n    - Don't write the full plan in one shot\n    - Get buy-in at each major step\n    - Allow course corrections\n    - Work collaboratively\n\n3. **Be Thorough**:\n\n    - Read all context files COMPLETELY before planning\n    - Research actual code patterns using parallel sub-tasks\n    - Include specific file paths and line numbers\n    - Write measurable success criteria with clear automated vs manual distinction\n    - automated steps should use `make` whenever possible - for example `make -C humanlayer-wui check` instead of `cd humanlayer-wui && bun run fmt`\n\n4. **Be Practical**:\n\n    - Focus on incremental, testable changes\n    - Consider migration and rollback\n    - Think about edge cases\n    - Include \"what we're NOT doing\"\n\n5. **Track Progress**:\n\n    - Use TodoWrite to track planning tasks\n    - Update todos as you complete research\n    - Mark planning tasks complete when done\n\n6. **No Open Questions in Final Plan**:\n    - If you encounter open questions during planning, STOP\n    - Research or ask for clarification immediately\n    - Do NOT write the plan with unresolved questions\n    - The implementation plan must be complete and actionable\n    - Every decision must be made before finalizing the plan\n\n## Success Criteria Guidelines\n\n**Always separate success criteria into two categories:**\n\n1. **Automated Verification** (can be run by execution agents):\n\n    - Commands that can be run: `make test`, `npm run lint`, etc.\n    - Specific files that should exist\n    - Code compilation/type checking\n    - Automated test suites\n\n2. **Manual Verification** (requires human testing):\n    - UI/UX functionality\n    - Performance under real conditions\n    - Edge cases that are hard to automate\n    - User acceptance criteria\n\n**Format example:**\n\n```markdown\n### Success Criteria:\n\n#### Automated Verification:\n\n-   [ ] Database migration runs successfully: `make migrate`\n-   [ ] All unit tests pass: `go test ./...`\n-   [ ] No linting errors: `golangci-lint run`\n-   [ ] API endpoint returns 200: `curl localhost:8080/api/new-endpoint`\n\n#### Manual Verification:\n\n-   [ ] New feature appears correctly in the UI\n-   [ ] Performance is acceptable with 1000+ items\n-   [ ] Error messages are user-friendly\n-   [ ] Feature works correctly on mobile devices\n```\n\n## Common Patterns\n\n### For Database Changes:\n\n-   Start with schema/migration\n-   Add store methods\n-   Update business logic\n-   Expose via API\n-   Update clients\n\n### For New Features:\n\n-   Research existing patterns first\n-   Start with data model\n-   Build backend logic\n-   Add API endpoints\n-   Implement UI last\n\n### For Refactoring:\n\n-   Document current behavior\n-   Plan incremental changes\n-   Maintain backwards compatibility\n-   Include migration strategy\n\n## Sub-task Spawning Best Practices\n\nWhen spawning research sub-tasks:\n\n1. **Spawn multiple tasks in parallel** for efficiency\n2. **Each task should be focused** on a specific area\n3. **Provide detailed instructions** including:\n    - Exactly what to search for\n    - Which directories to focus on\n    - What information to extract\n    - Expected output format\n4. **Be EXTREMELY specific about directories**:\n    - If the ticket mentions \"WUI\", specify `humanlayer-wui/` directory\n    - If it mentions \"daemon\", specify `hld/` directory\n    - Never use generic terms like \"UI\" when you mean \"WUI\"\n    - Include the full path context in your prompts\n5. **Specify read-only tools** to use\n6. **Request specific file:line references** in responses\n7. **Wait for all tasks to complete** before synthesizing\n8. **Verify sub-task results**:\n    - If a sub-task returns unexpected results, spawn follow-up tasks\n    - Cross-check findings against the actual codebase\n    - Don't accept results that seem incorrect\n\nExample of spawning multiple tasks:\n\n```python\n# Spawn these tasks concurrently:\ntasks = [\n    Task(\"Research database schema\", db_research_prompt),\n    Task(\"Find API patterns\", api_research_prompt),\n    Task(\"Investigate UI components\", ui_research_prompt),\n    Task(\"Check test patterns\", test_research_prompt)\n]\n```\n\n## Example Interaction Flow\n\n```\nUser: /create_plan\nAssistant: I'll help you create a detailed implementation plan...\n\nUser: We need to add parent-child tracking for Claude sub-tasks. See thoughts/allison/tickets/eng_1478.md\nAssistant: Let me read that ticket file completely first...\n\n[Reads file fully]\n\nBased on the ticket, I understand we need to track parent-child relationships for Claude sub-task events in the hld daemon. Before I start planning, I have some questions...\n\n[Interactive process continues...]\n```\n",
        "create_worktree": "\n---\ndescription: Create worktree and launch implementation session for a plan\n---\n\n2. set up worktree for implementation:\n2a. read `hack/create_worktree.sh` and create a new worktree with the Linear branch name: `./hack/create_worktree.sh ENG-XXXX BRANCH_NAME`\n\n3. determine required data:\n\nbranch name\npath to plan file (use relative path only)\nlaunch prompt\ncommand to run\n\n**IMPORTANT PATH USAGE:**\n- The thoughts/ directory is synced between the main repo and worktrees\n- Always use ONLY the relative path starting with `thoughts/shared/...` without any directory prefix\n- Example: `thoughts/shared/plans/fix-mcp-keepalive-proper.md` (not the full absolute path)\n- This works because thoughts are synced and accessible from the worktree\n\n3a. confirm with the user by sending a message to the Human\n\n```\nbased on the input, I plan to create a worktree with the following details:\n\nworktree path: ~/wt/humanlayer/ENG-XXXX\nbranch name: BRANCH_NAME\npath to plan file: $FILEPATH\nlaunch prompt:\n\n    /implement_plan at $FILEPATH and when you are done implementing and all tests pass, read ./claude/commands/commit.md and create a commit, then read ./claude/commands/describe_pr.md and create a PR, then add a comment to the Linear ticket with the PR link\n\ncommand to run:\n\n    humanlayer launch --model opus -w ~/wt/humanlayer/ENG-XXXX \"/implement_plan at $FILEPATH and when you are done implementing and all tests pass, read ./claude/commands/commit.md and create a commit, then read ./claude/commands/describe_pr.md and create a PR, then add a comment to the Linear ticket with the PR link\"\n```\n\nincorporate any user feedback then:\n\n4. launch implementation session: `humanlayer launch --model opus -w ~/wt/humanlayer/ENG-XXXX \"/implement_plan at $FILEPATH and when you are done implementing and all tests pass, read ./claude/commands/commit.md and create a commit, then read ./claude/commands/describe_pr.md and create a PR, then add a comment to the Linear ticket with the PR link\"`\n",
        "debug": "---\ndescription: Debug issues by investigating logs, database state, and git history\n---\n\n# Debug\n\nYou are tasked with helping debug issues during manual testing or implementation. This command allows you to investigate problems by examining logs, database state, and git history without editing files. Think of this as a way to bootstrap a debugging session without using the primary window's context.\n\n## Initial Response\n\nWhen invoked WITH a plan/ticket file:\n```\nI'll help debug issues with [file name]. Let me understand the current state.\n\nWhat specific problem are you encountering?\n- What were you trying to test/implement?\n- What went wrong?\n- Any error messages?\n\nI'll investigate the logs, database, and git state to help figure out what's happening.\n```\n\nWhen invoked WITHOUT parameters:\n```\nI'll help debug your current issue.\n\nPlease describe what's going wrong:\n- What are you working on?\n- What specific problem occurred?\n- When did it last work?\n\nI can investigate logs, database state, and recent changes to help identify the issue.\n```\n\n## Environment Information\n\nYou have access to these key locations and tools:\n\n**Logs** (automatically created by `make daemon` and `make wui`):\n- MCP logs: `~/.humanlayer/logs/mcp-claude-approvals-*.log`\n- Combined WUI/Daemon logs: `~/.humanlayer/logs/wui-${BRANCH_NAME}/codelayer.log`\n- First line shows: `[timestamp] starting [service] in [directory]`\n\n**Database**:\n- Location: `~/.humanlayer/daemon-{BRANCH_NAME}.db`\n- SQLite database with sessions, events, approvals, etc.\n- Can query directly with `sqlite3`\n\n**Git State**:\n- Check current branch, recent commits, uncommitted changes\n- Similar to how `commit` and `describe_pr` commands work\n\n**Service Status**:\n- Check if daemon is running: `ps aux | grep hld`\n- Check if WUI is running: `ps aux | grep wui`\n- Socket exists: `~/.humanlayer/daemon.sock`\n\n## Process Steps\n\n### Step 1: Understand the Problem\n\nAfter the user describes the issue:\n\n1. **Read any provided context** (plan or ticket file):\n   - Understand what they're implementing/testing\n   - Note which phase or step they're on\n   - Identify expected vs actual behavior\n\n2. **Quick state check**:\n   - Current git branch and recent commits\n   - Any uncommitted changes\n   - When the issue started occurring\n\n### Step 2: Investigate the Issue\n\nSpawn parallel Task agents for efficient investigation:\n\n```\nTask 1 - Check Recent Logs:\nFind and analyze the most recent logs for errors:\n1. Find latest daemon log: ls -t ~/.humanlayer/logs/daemon-*.log | head -1\n2. Find latest WUI log: ls -t ~/.humanlayer/logs/wui-*.log | head -1\n3. Search for errors, warnings, or issues around the problem timeframe\n4. Note the working directory (first line of log)\n5. Look for stack traces or repeated errors\nReturn: Key errors/warnings with timestamps\n```\n\n```\nTask 2 - Database State:\nCheck the current database state:\n1. Connect to database: sqlite3 ~/.humanlayer/daemon.db\n2. Check schema: .tables and .schema for relevant tables\n3. Query recent data:\n   - SELECT * FROM sessions ORDER BY created_at DESC LIMIT 5;\n   - SELECT * FROM conversation_events WHERE created_at > datetime('now', '-1 hour');\n   - Other queries based on the issue\n4. Look for stuck states or anomalies\nReturn: Relevant database findings\n```\n\n```\nTask 3 - Git and File State:\nUnderstand what changed recently:\n1. Check git status and current branch\n2. Look at recent commits: git log --oneline -10\n3. Check uncommitted changes: git diff\n4. Verify expected files exist\n5. Look for any file permission issues\nReturn: Git state and any file issues\n```\n\n### Step 3: Present Findings\n\nBased on the investigation, present a focused debug report:\n\n```markdown\n## Debug Report\n\n### What's Wrong\n[Clear statement of the issue based on evidence]\n\n### Evidence Found\n\n**From Logs** (`~/.humanlayer/logs/`):\n- [Error/warning with timestamp]\n- [Pattern or repeated issue]\n\n**From Database**:\n```sql\n-- Relevant query and result\n[Finding from database]\n```\n\n**From Git/Files**:\n- [Recent changes that might be related]\n- [File state issues]\n\n### Root Cause\n[Most likely explanation based on evidence]\n\n### Next Steps\n\n1. **Try This First**:\n   ```bash\n   [Specific command or action]\n   ```\n\n2. **If That Doesn't Work**:\n   - Restart services: `make daemon` and `make wui`\n   - Check browser console for WUI errors\n   - Run with debug: `HUMANLAYER_DEBUG=true make daemon`\n\n### Can't Access?\nSome issues might be outside my reach:\n- Browser console errors (F12 in browser)\n- MCP server internal state\n- System-level issues\n\nWould you like me to investigate something specific further?\n```\n\n## Important Notes\n\n- **Focus on manual testing scenarios** - This is for debugging during implementation\n- **Always require problem description** - Can't debug without knowing what's wrong\n- **Read files completely** - No limit/offset when reading context\n- **Think like `commit` or `describe_pr`** - Understand git state and changes\n- **Guide back to user** - Some issues (browser console, MCP internals) are outside reach\n- **No file editing** - Pure investigation only\n\n## Quick Reference\n\n**Find Latest Logs**:\n```bash\nls -t ~/.humanlayer/logs/daemon-*.log | head -1\nls -t ~/.humanlayer/logs/wui-*.log | head -1\n```\n\n**Database Queries**:\n```bash\nsqlite3 ~/.humanlayer/daemon.db \".tables\"\nsqlite3 ~/.humanlayer/daemon.db \".schema sessions\"\nsqlite3 ~/.humanlayer/daemon.db \"SELECT * FROM sessions ORDER BY created_at DESC LIMIT 5;\"\n```\n\n**Service Check**:\n```bash\nps aux | grep hld     # Is daemon running?\nps aux | grep wui     # Is WUI running?\n```\n\n**Git State**:\n```bash\ngit status\ngit log --oneline -10\ngit diff\n```\n\nRemember: This command helps you investigate without burning the primary window's context. Perfect for when you hit an issue during manual testing and need to dig into logs, database, or git state.\n",
        "describe_pr": "---\ndescription: Generate comprehensive PR descriptions following repository templates\n---\n\n# Generate PR Description\n\nYou are tasked with generating a comprehensive pull request description following the repository's standard template.\n\n## Steps to follow:\n\n1. **Read the PR description template:**\n   - First, check if `thoughts/shared/pr_description.md` exists\n   - If it doesn't exist, inform the user that their `humanlayer thoughts` setup is incomplete and they need to create a PR description template at `thoughts/shared/pr_description.md`\n   - Read the template carefully to understand all sections and requirements\n\n\n2. **Identify the PR to describe:**\n   - Check if the current branch has an associated PR: `gh pr view --json url,number,title,state 2>/dev/null`\n   - If no PR exists for the current branch, or if on main/master, list open PRs: `gh pr list --limit 10 --json number,title,headRefName,author`\n   - Ask the user which PR they want to describe\n\n3. **Check for existing description:**\n   - Check if `thoughts/shared/prs/{number}_description.md` already exists\n   - If it exists, read it and inform the user you'll be updating it\n   - Consider what has changed since the last description was written\n\n4. **Gather comprehensive PR information:**\n   - Get the full PR diff: `gh pr diff {number}`\n   - If you get an error about no default remote repository, instruct the user to run `gh repo set-default` and select the appropriate repository\n   - Get commit history: `gh pr view {number} --json commits`\n   - Review the base branch: `gh pr view {number} --json baseRefName`\n   - Get PR metadata: `gh pr view {number} --json url,title,number,state`\n\n5. **Analyze the changes thoroughly:** (ultrathink about the code changes, their architectural implications, and potential impacts)\n   - Read through the entire diff carefully\n   - For context, read any files that are referenced but not shown in the diff\n   - Understand the purpose and impact of each change\n   - Identify user-facing changes vs internal implementation details\n   - Look for breaking changes or migration requirements\n\n6. **Handle verification requirements:**\n   - Look for any checklist items in the \"How to verify it\" section of the template\n   - For each verification step:\n     - If it's a command you can run (like `make check test`, `npm test`, etc.), run it\n     - If it passes, mark the checkbox as checked: `- [x]`\n     - If it fails, keep it unchecked and note what failed: `- [ ]` with explanation\n     - If it requires manual testing (UI interactions, external services), leave unchecked and note for user\n   - Document any verification steps you couldn't complete\n\n7. **Generate the description:**\n   - Fill out each section from the template thoroughly:\n     - Answer each question/section based on your analysis\n     - Be specific about problems solved and changes made\n     - Focus on user impact where relevant\n     - Include technical details in appropriate sections\n     - Write a concise changelog entry\n   - Ensure all checklist items are addressed (checked or explained)\n\n8. **Save and sync the description:**\n   - Write the completed description to `thoughts/shared/prs/{number}_description.md`\n   - Run `humanlayer thoughts sync` to sync the thoughts directory\n   - Show the user the generated description\n\n9. **Update the PR:**\n   - Update the PR description directly: `gh pr edit {number} --body-file thoughts/shared/prs/{number}_description.md`\n   - Confirm the update was successful\n   - If any verification steps remain unchecked, remind the user to complete them before merging\n\n## Important notes:\n- This command works across different repositories - always read the local template\n- Be thorough but concise - descriptions should be scannable\n- Focus on the \"why\" as much as the \"what\"\n- Include any breaking changes or migration notes prominently\n- If the PR touches multiple components, organize the description accordingly\n- Always attempt to run verification commands when possible\n- Clearly communicate which verification steps need manual testing\n",
        "implement_plan": "---\ndescription: Implement technical plans from thoughts/shared/plans with verification\n---\n\n# Implement Plan\n\nYou are tasked with implementing an approved technical plan from `thoughts/shared/plans/`. These plans contain phases with specific changes and success criteria.\n\n## Getting Started\n\nWhen given a plan path:\n- Read the plan completely and check for any existing checkmarks (- [x])\n- Read the original ticket and all files mentioned in the plan\n- **Read files fully** - never use limit/offset parameters, you need complete context\n- Think deeply about how the pieces fit together\n- Create a todo list to track your progress\n- Start implementing if you understand what needs to be done\n\nIf no plan path provided, ask for one.\n\n## Implementation Philosophy\n\nPlans are carefully designed, but reality can be messy. Your job is to:\n- Follow the plan's intent while adapting to what you find\n- Implement each phase fully before moving to the next\n- Verify your work makes sense in the broader codebase context\n- Update checkboxes in the plan as you complete sections\n\nWhen things don't match the plan exactly, think about why and communicate clearly. The plan is your guide, but your judgment matters too.\n\nIf you encounter a mismatch:\n- STOP and think deeply about why the plan can't be followed\n- Present the issue clearly:\n  ```\n  Issue in Phase [N]:\n  Expected: [what the plan says]\n  Found: [actual situation]\n  Why this matters: [explanation]\n\n  How should I proceed?\n  ```\n\n## Verification Approach\n\nAfter implementing a phase:\n- Run the success criteria checks (usually `make check test` covers everything)\n- Fix any issues before proceeding\n- Update your progress in both the plan and your todos\n- Check off completed items in the plan file itself using Edit\n- **Pause for human verification**: After completing all automated verification for a phase, pause and inform the human that the phase is ready for manual testing. Use this format:\n  ```\n  Phase [N] Complete - Ready for Manual Verification\n\n  Automated verification passed:\n  - [List automated checks that passed]\n\n  Please perform the manual verification steps listed in the plan:\n  - [List manual verification items from the plan]\n\n  Let me know when manual testing is complete so I can proceed to Phase [N+1].\n  ```\n\nIf instructed to execute multiple phases consecutively, skip the pause until the last phase. Otherwise, assume you are just doing one phase.\n\ndo not check off items in the manual testing steps until confirmed by the user.\n\n\n## If You Get Stuck\n\nWhen something isn't working as expected:\n- First, make sure you've read and understood all the relevant code\n- Consider if the codebase has evolved since the plan was written\n- Present the mismatch clearly and ask for guidance\n\nUse sub-tasks sparingly - mainly for targeted debugging or exploring unfamiliar territory.\n\n## Resuming Work\n\nIf the plan has existing checkmarks:\n- Trust that completed work is done\n- Pick up from the first unchecked item\n- Verify previous work only if something seems off\n\nRemember: You're implementing a solution, not just checking boxes. Keep the end goal in mind and maintain forward momentum.\n",
        "iterate_plan": "---\ndescription: Iterate on existing implementation plans with thorough research and updates\nmodel: opus\n---\n\n# Iterate Implementation Plan\n\nYou are tasked with updating existing implementation plans based on user feedback. You should be skeptical, thorough, and ensure changes are grounded in actual codebase reality.\n\n## Initial Response\n\nWhen this command is invoked:\n\n1. **Parse the input to identify**:\n   - Plan file path (e.g., `thoughts/shared/plans/2025-10-16-feature.md`)\n   - Requested changes/feedback\n\n2. **Handle different input scenarios**:\n\n   **If NO plan file provided**:\n   ```\n   I'll help you iterate on an existing implementation plan.\n\n   Which plan would you like to update? Please provide the path to the plan file (e.g., `thoughts/shared/plans/2025-10-16-feature.md`).\n\n   Tip: You can list recent plans with `ls -lt thoughts/shared/plans/ | head`\n   ```\n   Wait for user input, then re-check for feedback.\n\n   **If plan file provided but NO feedback**:\n   ```\n   I've found the plan at [path]. What changes would you like to make?\n\n   For example:\n   - \"Add a phase for migration handling\"\n   - \"Update the success criteria to include performance tests\"\n   - \"Adjust the scope to exclude feature X\"\n   - \"Split Phase 2 into two separate phases\"\n   ```\n   Wait for user input.\n\n   **If BOTH plan file AND feedback provided**:\n   - Proceed immediately to Step 1\n   - No preliminary questions needed\n\n## Process Steps\n\n### Step 1: Read and Understand Current Plan\n\n1. **Read the existing plan file COMPLETELY**:\n   - Use the Read tool WITHOUT limit/offset parameters\n   - Understand the current structure, phases, and scope\n   - Note the success criteria and implementation approach\n\n2. **Understand the requested changes**:\n   - Parse what the user wants to add/modify/remove\n   - Identify if changes require codebase research\n   - Determine scope of the update\n\n### Step 2: Research If Needed\n\n**Only spawn research tasks if the changes require new technical understanding.**\n\nIf the user's feedback requires understanding new code patterns or validating assumptions:\n\n1. **Create a research todo list** using TodoWrite\n\n2. **Spawn parallel sub-tasks for research**:\n   Use the right agent for each type of research:\n\n   **For code investigation:**\n   - **codebase-locator** - To find relevant files\n   - **codebase-analyzer** - To understand implementation details\n   - **codebase-pattern-finder** - To find similar patterns\n\n   **For historical context:**\n   - **thoughts-locator** - To find related research or decisions\n   - **thoughts-analyzer** - To extract insights from documents\n\n   **Be EXTREMELY specific about directories**:\n   - If the change involves \"WUI\", specify `humanlayer-wui/` directory\n   - If it involves \"daemon\", specify `hld/` directory\n   - Include full path context in prompts\n\n3. **Read any new files identified by research**:\n   - Read them FULLY into the main context\n   - Cross-reference with the plan requirements\n\n4. **Wait for ALL sub-tasks to complete** before proceeding\n\n### Step 3: Present Understanding and Approach\n\nBefore making changes, confirm your understanding:\n\n```\nBased on your feedback, I understand you want to:\n- [Change 1 with specific detail]\n- [Change 2 with specific detail]\n\nMy research found:\n- [Relevant code pattern or constraint]\n- [Important discovery that affects the change]\n\nI plan to update the plan by:\n1. [Specific modification to make]\n2. [Another modification]\n\nDoes this align with your intent?\n```\n\nGet user confirmation before proceeding.\n\n### Step 4: Update the Plan\n\n1. **Make focused, precise edits** to the existing plan:\n   - Use the Edit tool for surgical changes\n   - Maintain the existing structure unless explicitly changing it\n   - Keep all file:line references accurate\n   - Update success criteria if needed\n\n2. **Ensure consistency**:\n   - If adding a new phase, ensure it follows the existing pattern\n   - If modifying scope, update \"What We're NOT Doing\" section\n   - If changing approach, update \"Implementation Approach\" section\n   - Maintain the distinction between automated vs manual success criteria\n\n3. **Preserve quality standards**:\n   - Include specific file paths and line numbers for new content\n   - Write measurable success criteria\n   - Use `make` commands for automated verification\n   - Keep language clear and actionable\n\n### Step 5: Sync and Review\n\n1. **Sync the updated plan**:\n   - Run `humanlayer thoughts sync`\n   - This ensures changes are properly indexed\n\n2. **Present the changes made**:\n   ```\n   I've updated the plan at `thoughts/shared/plans/[filename].md`\n\n   Changes made:\n   - [Specific change 1]\n   - [Specific change 2]\n\n   The updated plan now:\n   - [Key improvement]\n   - [Another improvement]\n\n   Would you like any further adjustments?\n   ```\n\n3. **Be ready to iterate further** based on feedback\n\n## Important Guidelines\n\n1. **Be Skeptical**:\n   - Don't blindly accept change requests that seem problematic\n   - Question vague feedback - ask for clarification\n   - Verify technical feasibility with code research\n   - Point out potential conflicts with existing plan phases\n\n2. **Be Surgical**:\n   - Make precise edits, not wholesale rewrites\n   - Preserve good content that doesn't need changing\n   - Only research what's necessary for the specific changes\n   - Don't over-engineer the updates\n\n3. **Be Thorough**:\n   - Read the entire existing plan before making changes\n   - Research code patterns if changes require new technical understanding\n   - Ensure updated sections maintain quality standards\n   - Verify success criteria are still measurable\n\n4. **Be Interactive**:\n   - Confirm understanding before making changes\n   - Show what you plan to change before doing it\n   - Allow course corrections\n   - Don't disappear into research without communicating\n\n5. **Track Progress**:\n   - Use TodoWrite to track update tasks if complex\n   - Update todos as you complete research\n   - Mark tasks complete when done\n\n6. **No Open Questions**:\n   - If the requested change raises questions, ASK\n   - Research or get clarification immediately\n   - Do NOT update the plan with unresolved questions\n   - Every change must be complete and actionable\n\n## Success Criteria Guidelines\n\nWhen updating success criteria, always maintain the two-category structure:\n\n1. **Automated Verification** (can be run by execution agents):\n   - Commands that can be run: `make test`, `npm run lint`, etc.\n   - Prefer `make` commands: `make -C humanlayer-wui check` instead of `cd humanlayer-wui && bun run fmt`\n   - Specific files that should exist\n   - Code compilation/type checking\n\n2. **Manual Verification** (requires human testing):\n   - UI/UX functionality\n   - Performance under real conditions\n   - Edge cases that are hard to automate\n   - User acceptance criteria\n\n## Sub-task Spawning Best Practices\n\nWhen spawning research sub-tasks:\n\n1. **Only spawn if truly needed** - don't research for simple changes\n2. **Spawn multiple tasks in parallel** for efficiency\n3. **Each task should be focused** on a specific area\n4. **Provide detailed instructions** including:\n   - Exactly what to search for\n   - Which directories to focus on\n   - What information to extract\n   - Expected output format\n5. **Request specific file:line references** in responses\n6. **Wait for all tasks to complete** before synthesizing\n7. **Verify sub-task results** - if something seems off, spawn follow-up tasks\n\n## Example Interaction Flows\n\n**Scenario 1: User provides everything upfront**\n```\nUser: /iterate_plan thoughts/shared/plans/2025-10-16-feature.md - add phase for error handling\nAssistant: [Reads plan, researches error handling patterns, updates plan]\n```\n\n**Scenario 2: User provides just plan file**\n```\nUser: /iterate_plan thoughts/shared/plans/2025-10-16-feature.md\nAssistant: I've found the plan. What changes would you like to make?\nUser: Split Phase 2 into two phases - one for backend, one for frontend\nAssistant: [Proceeds with update]\n```\n\n**Scenario 3: User provides no arguments**\n```\nUser: /iterate_plan\nAssistant: Which plan would you like to update? Please provide the path...\nUser: thoughts/shared/plans/2025-10-16-feature.md\nAssistant: I've found the plan. What changes would you like to make?\nUser: Add more specific success criteria\nAssistant: [Proceeds with update]\n```\n",
        "linear": "---\ndescription: Manage Linear tickets - create, update, comment, and follow workflow patterns\n---\n\n# Linear - Ticket Management\n\nYou are tasked with managing Linear tickets, including creating tickets from thoughts documents, updating existing tickets, and following the team's specific workflow patterns.\n\n## Initial Setup\n\nFirst, verify that Linear MCP tools are available by checking if any `mcp__linear__` tools exist. If not, respond:\n```\nI need access to Linear tools to help with ticket management. Please run the `/mcp` command to enable the Linear MCP server, then try again.\n```\n\nIf tools are available, respond based on the user's request:\n\n### For general requests:\n```\nI can help you with Linear tickets. What would you like to do?\n1. Create a new ticket from a thoughts document\n2. Add a comment to a ticket (I'll use our conversation context)\n3. Search for tickets\n4. Update ticket status or details\n```\n\n### For specific create requests:\n```\nI'll help you create a Linear ticket from your thoughts document. Please provide:\n1. The path to the thoughts document (or topic to search for)\n2. Any specific focus or angle for the ticket (optional)\n```\n\nThen wait for the user's input.\n\n## Team Workflow & Status Progression\n\nThe team follows a specific workflow to ensure alignment before code implementation:\n\n1. **Triage** → All new tickets start here for initial review\n2. **Spec Needed** → More detail is needed - problem to solve and solution outline necessary\n3. **Research Needed** → Ticket requires investigation before plan can be written\n4. **Research in Progress** → Active research/investigation underway\n5. **Research in Review** → Research findings under review (optional step)\n6. **Ready for Plan** → Research complete, ticket needs an implementation plan\n7. **Plan in Progress** → Actively writing the implementation plan\n8. **Plan in Review** → Plan is written and under discussion\n9. **Ready for Dev** → Plan approved, ready for implementation\n10. **In Dev** → Active development\n11. **Code Review** → PR submitted\n12. **Done** → Completed\n\n**Key principle**: Review and alignment happen at the plan stage (not PR stage) to move faster and avoid rework.\n\n## Important Conventions\n\n### URL Mapping for Thoughts Documents\nWhen referencing thoughts documents, always provide GitHub links using the `links` parameter:\n- `thoughts/shared/...` → `https://github.com/humanlayer/thoughts/blob/main/repos/humanlayer/shared/...`\n- `thoughts/allison/...` → `https://github.com/humanlayer/thoughts/blob/main/repos/humanlayer/allison/...`\n- `thoughts/global/...` → `https://github.com/humanlayer/thoughts/blob/main/global/...`\n\n### Default Values\n- **Status**: Always create new tickets in \"Triage\" status\n- **Project**: For new tickets, default to \"M U L T I C L A U D E\" (ID: f11c8d63-9120-4393-bfae-553da0b04fd8) unless told otherwise\n- **Priority**: Default to Medium (3) for most tasks, use best judgment or ask user\n  - Urgent (1): Critical blockers, security issues\n  - High (2): Important features with deadlines, major bugs\n  - Medium (3): Standard implementation tasks (default)\n  - Low (4): Nice-to-haves, minor improvements\n- **Links**: Use the `links` parameter to attach URLs (not just markdown links in description)\n\n### Automatic Label Assignment\nAutomatically apply labels based on the ticket content:\n- **hld**: For tickets about the `hld/` directory (the daemon)\n- **wui**: For tickets about `humanlayer-wui/`\n- **meta**: For tickets about `hlyr` commands, thoughts tool, or `thoughts/` directory\n\nNote: meta is mutually exclusive with hld/wui. Tickets can have both hld and wui, but not meta with either.\n\n## Action-Specific Instructions\n\n### 1. Creating Tickets from Thoughts\n\n#### Steps to follow after receiving the request:\n\n1. **Locate and read the thoughts document:**\n   - If given a path, read the document directly\n   - If given a topic/keyword, search thoughts/ directory using Grep to find relevant documents\n   - If multiple matches found, show list and ask user to select\n   - Create a TodoWrite list to track: Read document → Analyze content → Draft ticket → Get user input → Create ticket\n\n2. **Analyze the document content:**\n   - Identify the core problem or feature being discussed\n   - Extract key implementation details or technical decisions\n   - Note any specific code files or areas mentioned\n   - Look for action items or next steps\n   - Identify what stage the idea is at (early ideation vs ready to implement)\n   - Take time to ultrathink about distilling the essence of this document into a clear problem statement and solution approach\n\n3. **Check for related context (if mentioned in doc):**\n   - If the document references specific code files, read relevant sections\n   - If it mentions other thoughts documents, quickly check them\n   - Look for any existing Linear tickets mentioned\n\n4. **Get Linear workspace context:**\n   - List teams: `mcp__linear__list_teams`\n   - If multiple teams, ask user to select one\n   - List projects for selected team: `mcp__linear__list_projects`\n\n5. **Draft the ticket summary:**\n   Present a draft to the user:\n   ```\n   ## Draft Linear Ticket\n\n   **Title**: [Clear, action-oriented title]\n\n   **Description**:\n   [2-3 sentence summary of the problem/goal]\n\n   ## Key Details\n   - [Bullet points of important details from thoughts]\n   - [Technical decisions or constraints]\n   - [Any specific requirements]\n\n   ## Implementation Notes (if applicable)\n   [Any specific technical approach or steps outlined]\n\n   ## References\n   - Source: `thoughts/[path/to/document.md]` ([View on GitHub](converted GitHub URL))\n   - Related code: [any file:line references]\n   - Parent ticket: [if applicable]\n\n   ---\n   Based on the document, this seems to be at the stage of: [ideation/planning/ready to implement]\n   ```\n\n6. **Interactive refinement:**\n   Ask the user:\n   - Does this summary capture the ticket accurately?\n   - Which project should this go in? [show list]\n   - What priority? (Default: Medium/3)\n   - Any additional context to add?\n   - Should we include more/less implementation detail?\n   - Do you want to assign it to yourself?\n\n   Note: Ticket will be created in \"Triage\" status by default.\n\n7. **Create the Linear ticket:**\n   ```\n   mcp__linear__create_issue with:\n   - title: [refined title]\n   - description: [final description in markdown]\n   - teamId: [selected team]\n   - projectId: [use default project from above unless user specifies]\n   - priority: [selected priority number, default 3]\n   - stateId: [Triage status ID]\n   - assigneeId: [if requested]\n   - labelIds: [apply automatic label assignment from above]\n   - links: [{url: \"GitHub URL\", title: \"Document Title\"}]\n   ```\n\n8. **Post-creation actions:**\n   - Show the created ticket URL\n   - Ask if user wants to:\n     - Add a comment with additional implementation details\n     - Create sub-tasks for specific action items\n     - Update the original thoughts document with the ticket reference\n   - If yes to updating thoughts doc:\n     ```\n     Add at the top of the document:\n     ---\n     linear_ticket: [URL]\n     created: [date]\n     ---\n     ```\n\n## Example transformations:\n\n### From verbose thoughts:\n```\n\"I've been thinking about how our resumed sessions don't inherit permissions properly.\nThis is causing issues where users have to re-specify everything. We should probably\nstore all the config in the database and then pull it when resuming. Maybe we need\nnew columns for permission_prompt_tool and allowed_tools...\"\n```\n\n### To concise ticket:\n```\nTitle: Fix resumed sessions to inherit all configuration from parent\n\nDescription:\n\n## Problem to solve\nCurrently, resumed sessions only inherit Model and WorkingDir from parent sessions,\ncausing all other configuration to be lost. Users must re-specify permissions and\nsettings when resuming.\n\n## Solution\nStore all session configuration in the database and automatically inherit it when\nresuming sessions, with support for explicit overrides.\n```\n\n### 2. Adding Comments and Links to Existing Tickets\n\nWhen user wants to add a comment to a ticket:\n\n1. **Determine which ticket:**\n   - Use context from the current conversation to identify the relevant ticket\n   - If uncertain, use `mcp__linear__get_issue` to show ticket details and confirm with user\n   - Look for ticket references in recent work discussed\n\n2. **Format comments for clarity:**\n   - Attempt to keep comments concise (~10 lines) unless more detail is needed\n   - Focus on the key insight or most useful information for a human reader\n   - Not just what was done, but what matters about it\n   - Include relevant file references with backticks and GitHub links\n\n3. **File reference formatting:**\n   - Wrap paths in backticks: `thoughts/allison/example.md`\n   - Add GitHub link after: `([View](url))`\n   - Do this for both thoughts/ and code files mentioned\n\n4. **Comment structure example:**\n   ```markdown\n   Implemented retry logic in webhook handler to address rate limit issues.\n\n   Key insight: The 429 responses were clustered during batch operations,\n   so exponential backoff alone wasn't sufficient - added request queuing.\n\n   Files updated:\n   - `hld/webhooks/handler.go` ([GitHub](link))\n   - `thoughts/shared/rate_limit_analysis.md` ([GitHub](link))\n   ```\n\n5. **Handle links properly:**\n   - If adding a link with a comment: Update the issue with the link AND mention it in the comment\n   - If only adding a link: Still create a comment noting what link was added for posterity\n   - Always add links to the issue itself using the `links` parameter\n\n6. **For comments with links:**\n   ```\n   # First, update the issue with the link\n   mcp__linear__update_issue with:\n   - id: [ticket ID]\n   - links: [existing links + new link with proper title]\n\n   # Then, create the comment mentioning the link\n   mcp__linear__create_comment with:\n   - issueId: [ticket ID]\n   - body: [formatted comment with key insights and file references]\n   ```\n\n7. **For links only:**\n   ```\n   # Update the issue with the link\n   mcp__linear__update_issue with:\n   - id: [ticket ID]\n   - links: [existing links + new link with proper title]\n\n   # Add a brief comment for posterity\n   mcp__linear__create_comment with:\n   - issueId: [ticket ID]\n   - body: \"Added link: `path/to/document.md` ([View](url))\"\n   ```\n\n### 3. Searching for Tickets\n\nWhen user wants to find tickets:\n\n1. **Gather search criteria:**\n   - Query text\n   - Team/Project filters\n   - Status filters\n   - Date ranges (createdAt, updatedAt)\n\n2. **Execute search:**\n   ```\n   mcp__linear__list_issues with:\n   - query: [search text]\n   - teamId: [if specified]\n   - projectId: [if specified]\n   - stateId: [if filtering by status]\n   - limit: 20\n   ```\n\n3. **Present results:**\n   - Show ticket ID, title, status, assignee\n   - Group by project if multiple projects\n   - Include direct links to Linear\n\n### 4. Updating Ticket Status\n\nWhen moving tickets through the workflow:\n\n1. **Get current status:**\n   - Fetch ticket details\n   - Show current status in workflow\n\n2. **Suggest next status:**\n   - Triage → Spec Needed (lacks detail/problem statement)\n   - Spec Needed → Research Needed (once problem/solution outlined)\n   - Research Needed → Research in Progress (starting research)\n   - Research in Progress → Research in Review (optional, can skip to Ready for Plan)\n   - Research in Review → Ready for Plan (research approved)\n   - Ready for Plan → Plan in Progress (starting to write plan)\n   - Plan in Progress → Plan in Review (plan written)\n   - Plan in Review → Ready for Dev (plan approved)\n   - Ready for Dev → In Dev (work started)\n\n3. **Update with context:**\n   ```\n   mcp__linear__update_issue with:\n   - id: [ticket ID]\n   - stateId: [new status ID]\n   ```\n\n   Consider adding a comment explaining the status change.\n\n## Important Notes\n\n- Tag users in descriptions and comments using `@[name](ID)` format, e.g., `@[dex](16765c85-2286-4c0f-ab49-0d4d79222ef5)`\n- Keep tickets concise but complete - aim for scannable content\n- All tickets should include a clear \"problem to solve\" - if the user asks for a ticket and only gives implementation details, you MUST ask \"To write a good ticket, please explain the problem you're trying to solve from a user perspective\"\n- Focus on the \"what\" and \"why\", include \"how\" only if well-defined\n- Always preserve links to source material using the `links` parameter\n- Don't create tickets from early-stage brainstorming unless requested\n- Use proper Linear markdown formatting\n- Include code references as: `path/to/file.ext:linenum`\n- Ask for clarification rather than guessing project/status\n- Remember that Linear descriptions support full markdown including code blocks\n- Always use the `links` parameter for external URLs (not just markdown links)\n- remember - you must get a \"Problem to solve\"!\n\n## Comment Quality Guidelines\n\nWhen creating comments, focus on extracting the **most valuable information** for a human reader:\n\n- **Key insights over summaries**: What's the \"aha\" moment or critical understanding?\n- **Decisions and tradeoffs**: What approach was chosen and what it enables/prevents\n- **Blockers resolved**: What was preventing progress and how it was addressed\n- **State changes**: What's different now and what it means for next steps\n- **Surprises or discoveries**: Unexpected findings that affect the work\n\nAvoid:\n- Mechanical lists of changes without context\n- Restating what's obvious from code diffs\n- Generic summaries that don't add value\n\nRemember: The goal is to help a future reader (including yourself) quickly understand what matters about this update.\n\n## Commonly Used IDs\n\n### Engineering Team\n- **Team ID**: `6b3b2115-efd4-4b83-8463-8160842d2c84`\n\n### Label IDs\n- **bug**: `ff23dde3-199b-421e-904c-4b9f9b3d452c`\n- **hld**: `d28453c8-e53e-4a06-bea9-b5bbfad5f88a`\n- **meta**: `7a5abaae-f343-4f52-98b0-7987048b0cfa`\n- **wui**: `996deb94-ba0f-4375-8b01-913e81477c4b`\n\n### Workflow State IDs\n- **Triage**: `77da144d-fe13-4c3a-a53a-cfebd06c0cbe` (type: triage)\n- **spec needed**: `274beb99-bff8-4d7b-85cf-04d18affbc82` (type: unstarted)\n- **research needed**: `d0b89672-8189-45d6-b705-50afd6c94a91` (type: unstarted)\n- **research in progress**: `c41c5a23-ce25-471f-b70a-eff1dca60ffd` (type: unstarted)\n- **research in review**: `1a9363a7-3fae-42ee-a6c8-1fc714656f09` (type: unstarted)\n- **ready for plan**: `995011dd-3e36-46e5-b776-5a4628d06cc8` (type: unstarted)\n- **plan in progress**: `a52b4793-d1b6-4e5d-be79-b2254185eed0` (type: started)\n- **plan in review**: `15f56065-41ea-4d9a-ab8c-ec8e1a811a7a` (type: started)\n- **ready for dev**: `c25bae2f-856a-4718-aaa8-b469b7822f58` (type: started)\n- **in dev**: `6be18699-18d7-496e-a7c9-37d2ddefe612` (type: started)\n- **code review**: `8ca7fda1-08d4-48fb-a0cf-954246ccbe66` (type: started)\n- **Ready for Deploy**: `a3ad0b54-17bf-4ad3-b1c1-2f56c1f2515a` (type: started)\n- **Done**: `8159f431-fbc7-495f-a861-1ba12040f672` (type: completed)\n- **Backlog**: `6cf6b25a-054a-469b-9845-9bd9ab39ad76` (type: backlog)\n- **PostIts**: `a57f2ab3-c6f8-44c7-a36b-896154729338` (type: backlog)\n- **Todo**: `ddf85246-3a7c-4141-a377-09069812bbc3` (type: unstarted)\n- **Duplicate**: `2bc0e829-9853-4f76-ad34-e8732f062da2` (type: canceled)\n- **Canceled**: `14a28d0d-c6aa-4d8e-9ff2-9801d4cc7de1` (type: canceled)\n\n\n## Linear User IDs\n\n- allison: b157f9e4-8faf-4e7e-a598-dae6dec8a584\n- dex: 16765c85-2286-4c0f-ab49-0d4d79222ef5\n- sundeep: 0062104d-9351-44f5-b64c-d0b59acb516b\n",
        "research_codebase": "---\ndescription: Document codebase as-is with thoughts directory for historical context\nmodel: opus\n---\n\n# Research Codebase\n\nYou are tasked with conducting comprehensive research across the codebase to answer user questions by spawning parallel sub-agents and synthesizing their findings.\n\n## CRITICAL: YOUR ONLY JOB IS TO DOCUMENT AND EXPLAIN THE CODEBASE AS IT EXISTS TODAY\n- DO NOT suggest improvements or changes unless the user explicitly asks for them\n- DO NOT perform root cause analysis unless the user explicitly asks for them\n- DO NOT propose future enhancements unless the user explicitly asks for them\n- DO NOT critique the implementation or identify problems\n- DO NOT recommend refactoring, optimization, or architectural changes\n- ONLY describe what exists, where it exists, how it works, and how components interact\n- You are creating a technical map/documentation of the existing system\n\n## Initial Setup:\n\nWhen this command is invoked, respond with:\n```\nI'm ready to research the codebase. Please provide your research question or area of interest, and I'll analyze it thoroughly by exploring relevant components and connections.\n```\n\nThen wait for the user's research query.\n\n## Steps to follow after receiving the research query:\n\n1. **Read any directly mentioned files first:**\n   - If the user mentions specific files (tickets, docs, JSON), read them FULLY first\n   - **IMPORTANT**: Use the Read tool WITHOUT limit/offset parameters to read entire files\n   - **CRITICAL**: Read these files yourself in the main context before spawning any sub-tasks\n   - This ensures you have full context before decomposing the research\n\n2. **Analyze and decompose the research question:**\n   - Break down the user's query into composable research areas\n   - Take time to ultrathink about the underlying patterns, connections, and architectural implications the user might be seeking\n   - Identify specific components, patterns, or concepts to investigate\n   - Create a research plan using TodoWrite to track all subtasks\n   - Consider which directories, files, or architectural patterns are relevant\n\n3. **Spawn parallel sub-agent tasks for comprehensive research:**\n   - Create multiple Task agents to research different aspects concurrently\n   - We now have specialized agents that know how to do specific research tasks:\n\n   **For codebase research:**\n   - Use the **codebase-locator** agent to find WHERE files and components live\n   - Use the **codebase-analyzer** agent to understand HOW specific code works (without critiquing it)\n   - Use the **codebase-pattern-finder** agent to find examples of existing patterns (without evaluating them)\n\n   **IMPORTANT**: All agents are documentarians, not critics. They will describe what exists without suggesting improvements or identifying issues.\n\n   **For thoughts directory:**\n   - Use the **thoughts-locator** agent to discover what documents exist about the topic\n   - Use the **thoughts-analyzer** agent to extract key insights from specific documents (only the most relevant ones)\n\n   **For web research (only if user explicitly asks):**\n   - Use the **web-search-researcher** agent for external documentation and resources\n   - IF you use web-research agents, instruct them to return LINKS with their findings, and please INCLUDE those links in your final report\n\n   **For Linear tickets (if relevant):**\n   - Use the **linear-ticket-reader** agent to get full details of a specific ticket\n   - Use the **linear-searcher** agent to find related tickets or historical context\n\n   The key is to use these agents intelligently:\n   - Start with locator agents to find what exists\n   - Then use analyzer agents on the most promising findings to document how they work\n   - Run multiple agents in parallel when they're searching for different things\n   - Each agent knows its job - just tell it what you're looking for\n   - Don't write detailed prompts about HOW to search - the agents already know\n   - Remind agents they are documenting, not evaluating or improving\n\n4. **Wait for all sub-agents to complete and synthesize findings:**\n   - IMPORTANT: Wait for ALL sub-agent tasks to complete before proceeding\n   - Compile all sub-agent results (both codebase and thoughts findings)\n   - Prioritize live codebase findings as primary source of truth\n   - Use thoughts/ findings as supplementary historical context\n   - Connect findings across different components\n   - Include specific file paths and line numbers for reference\n   - Verify all thoughts/ paths are correct (e.g., thoughts/allison/ not thoughts/shared/ for personal files)\n   - Highlight patterns, connections, and architectural decisions\n   - Answer the user's specific questions with concrete evidence\n\n5. **Gather metadata for the research document:**\n   - Run the `hack/spec_metadata.sh` script to generate all relevant metadata\n   - Filename: `thoughts/shared/research/YYYY-MM-DD-ENG-XXXX-description.md`\n     - Format: `YYYY-MM-DD-ENG-XXXX-description.md` where:\n       - YYYY-MM-DD is today's date\n       - ENG-XXXX is the ticket number (omit if no ticket)\n       - description is a brief kebab-case description of the research topic\n     - Examples:\n       - With ticket: `2025-01-08-ENG-1478-parent-child-tracking.md`\n       - Without ticket: `2025-01-08-authentication-flow.md`\n\n6. **Generate research document:**\n   - Use the metadata gathered in step 4\n   - Structure the document with YAML frontmatter followed by content:\n     ```markdown\n     ---\n     date: [Current date and time with timezone in ISO format]\n     researcher: [Researcher name from thoughts status]\n     git_commit: [Current commit hash]\n     branch: [Current branch name]\n     repository: [Repository name]\n     topic: \"[User's Question/Topic]\"\n     tags: [research, codebase, relevant-component-names]\n     status: complete\n     last_updated: [Current date in YYYY-MM-DD format]\n     last_updated_by: [Researcher name]\n     ---\n\n     # Research: [User's Question/Topic]\n\n     **Date**: [Current date and time with timezone from step 4]\n     **Researcher**: [Researcher name from thoughts status]\n     **Git Commit**: [Current commit hash from step 4]\n     **Branch**: [Current branch name from step 4]\n     **Repository**: [Repository name]\n\n     ## Research Question\n     [Original user query]\n\n     ## Summary\n     [High-level documentation of what was found, answering the user's question by describing what exists]\n\n     ## Detailed Findings\n\n     ### [Component/Area 1]\n     - Description of what exists ([file.ext:line](link))\n     - How it connects to other components\n     - Current implementation details (without evaluation)\n\n     ### [Component/Area 2]\n     ...\n\n     ## Code References\n     - `path/to/file.py:123` - Description of what's there\n     - `another/file.ts:45-67` - Description of the code block\n\n     ## Architecture Documentation\n     [Current patterns, conventions, and design implementations found in the codebase]\n\n     ## Historical Context (from thoughts/)\n     [Relevant insights from thoughts/ directory with references]\n     - `thoughts/shared/something.md` - Historical decision about X\n     - `thoughts/local/notes.md` - Past exploration of Y\n     Note: Paths exclude \"searchable/\" even if found there\n\n     ## Related Research\n     [Links to other research documents in thoughts/shared/research/]\n\n     ## Open Questions\n     [Any areas that need further investigation]\n     ```\n\n7. **Add GitHub permalinks (if applicable):**\n   - Check if on main branch or if commit is pushed: `git branch --show-current` and `git status`\n   - If on main/master or pushed, generate GitHub permalinks:\n     - Get repo info: `gh repo view --json owner,name`\n     - Create permalinks: `https://github.com/{owner}/{repo}/blob/{commit}/{file}#L{line}`\n   - Replace local file references with permalinks in the document\n\n8. **Sync and present findings:**\n   - Run `humanlayer thoughts sync` to sync the thoughts directory\n   - Present a concise summary of findings to the user\n   - Include key file references for easy navigation\n   - Ask if they have follow-up questions or need clarification\n\n9. **Handle follow-up questions:**\n   - If the user has follow-up questions, append to the same research document\n   - Update the frontmatter fields `last_updated` and `last_updated_by` to reflect the update\n   - Add `last_updated_note: \"Added follow-up research for [brief description]\"` to frontmatter\n   - Add a new section: `## Follow-up Research [timestamp]`\n   - Spawn new sub-agents as needed for additional investigation\n   - Continue updating the document and syncing\n\n## Important notes:\n- Always use parallel Task agents to maximize efficiency and minimize context usage\n- Always run fresh codebase research - never rely solely on existing research documents\n- The thoughts/ directory provides historical context to supplement live findings\n- Focus on finding concrete file paths and line numbers for developer reference\n- Research documents should be self-contained with all necessary context\n- Each sub-agent prompt should be specific and focused on read-only documentation operations\n- Document cross-component connections and how systems interact\n- Include temporal context (when the research was conducted)\n- Link to GitHub when possible for permanent references\n- Keep the main agent focused on synthesis, not deep file reading\n- Have sub-agents document examples and usage patterns as they exist\n- Explore all of thoughts/ directory, not just research subdirectory\n- **CRITICAL**: You and all sub-agents are documentarians, not evaluators\n- **REMEMBER**: Document what IS, not what SHOULD BE\n- **NO RECOMMENDATIONS**: Only describe the current state of the codebase\n- **File reading**: Always read mentioned files FULLY (no limit/offset) before spawning sub-tasks\n- **Critical ordering**: Follow the numbered steps exactly\n  - ALWAYS read mentioned files first before spawning sub-tasks (step 1)\n  - ALWAYS wait for all sub-agents to complete before synthesizing (step 4)\n  - ALWAYS gather metadata before writing the document (step 5 before step 6)\n  - NEVER write the research document with placeholder values\n- **Path handling**: The thoughts/searchable/ directory contains hard links for searching\n  - Always document paths by removing ONLY \"searchable/\" - preserve all other subdirectories\n  - Examples of correct transformations:\n    - `thoughts/searchable/allison/old_stuff/notes.md` → `thoughts/allison/old_stuff/notes.md`\n    - `thoughts/searchable/shared/prs/123.md` → `thoughts/shared/prs/123.md`\n    - `thoughts/searchable/global/shared/templates.md` → `thoughts/global/shared/templates.md`\n  - NEVER change allison/ to shared/ or vice versa - preserve the exact directory structure\n  - This ensures paths are correct for editing and navigation\n- **Frontmatter consistency**:\n  - Always include frontmatter at the beginning of research documents\n  - Keep frontmatter fields consistent across all research documents\n  - Update frontmatter when adding follow-up research\n  - Use snake_case for multi-word field names (e.g., `last_updated`, `git_commit`)\n  - Tags should be relevant to the research topic and components studied\n",
        "resume_handoff": "---\ndescription: Resume work from handoff document with context analysis and validation\n---\n\n# Resume work from a handoff document\n\nYou are tasked with resuming work from a handoff document through an interactive process. These handoffs contain critical context, learnings, and next steps from previous work sessions that need to be understood and continued.\n\n## Initial Response\n\nWhen this command is invoked:\n\n1. **If the path to a handoff document was provided**:\n   - If a handoff document path was provided as a parameter, skip the default message\n   - Immediately read the handoff document FULLY\n   - Immediately read any research or plan documents that it links to under `thoughts/shared/plans` or `thoughts/shared/research`. do NOT use a sub-agent to read these critical files.\n   - Begin the analysis process by ingesting relevant context from the handoff document, reading additional files it mentions\n   - Then propose a course of action to the user and confirm, or ask for clarification on direction.\n\n2. **If a ticket number (like ENG-XXXX) was provided**:\n   - run `humanlayer thoughts sync` to ensure your `thoughts/` directory is up to date.\n   - locate the most recent handoff document for the ticket. Tickets will be located in `thoughts/shared/handoffs/ENG-XXXX` where `ENG-XXXX` is the ticket number. e.g. for `ENG-2124` the handoffs would be in `thoughts/shared/handoffs/ENG-2124/`. **List this directory's contents.**\n   - There may be zero, one or multiple files in the directory.\n   - **If there are zero files in the directory, or the directory does not exist**: tell the user: \"I'm sorry, I can't seem to find that handoff document. Can you please provide me with a path to it?\"\n   - **If there is only one file in the directory**: proceed with that handoff\n   - **If there are multiple files in the directory**: using the date and time specified in the file name (it will be in the format `YYYY-MM-DD_HH-MM-SS` in 24-hour time format), proceed with the _most recent_ handoff document.\n   - Immediately read the handoff document FULLY\n   - Immediately read any research or plan documents that it links to under `thoughts/shared/plans` or `thoughts/shared/research`; do NOT use a sub-agent to read these critical files.\n   - Begin the analysis process by ingesting relevant context from the handoff document, reading additional files it mentions\n   - Then propose a course of action to the user and confirm, or ask for clarification on direction.\n\n3. **If no parameters provided**, respond with:\n```\nI'll help you resume work from a handoff document. Let me find the available handoffs.\n\nWhich handoff would you like to resume from?\n\nTip: You can invoke this command directly with a handoff path: `/resume_handoff `thoughts/shared/handoffs/ENG-XXXX/YYYY-MM-DD_HH-MM-SS_ENG-XXXX_description.md`\n\nor using a ticket number to resume from the most recent handoff for that ticket: `/resume_handoff ENG-XXXX`\n```\n\nThen wait for the user's input.\n\n## Process Steps\n\n### Step 1: Read and Analyze Handoff\n\n1. **Read handoff document completely**:\n   - Use the Read tool WITHOUT limit/offset parameters\n   - Extract all sections:\n     - Task(s) and their statuses\n     - Recent changes\n     - Learnings\n     - Artifacts\n     - Action items and next steps\n     - Other notes\n\n2. **Spawn focused research tasks**:\n   Based on the handoff content, spawn parallel research tasks to verify current state:\n\n   ```\n   Task 1 - Gather artifact context:\n   Read all artifacts mentioned in the handoff.\n   1. Read feature documents listed in \"Artifacts\"\n   2. Read implementation plans referenced\n   3. Read any research documents mentioned\n   4. Extract key requirements and decisions\n   Use tools: Read\n   Return: Summary of artifact contents and key decisions\n   ```\n\n3. **Wait for ALL sub-tasks to complete** before proceeding\n\n4. **Read critical files identified**:\n   - Read files from \"Learnings\" section completely\n   - Read files from \"Recent changes\" to understand modifications\n   - Read any new related files discovered during research\n\n### Step 2: Synthesize and Present Analysis\n\n1. **Present comprehensive analysis**:\n   ```\n   I've analyzed the handoff from [date] by [researcher]. Here's the current situation:\n\n   **Original Tasks:**\n   - [Task 1]: [Status from handoff] → [Current verification]\n   - [Task 2]: [Status from handoff] → [Current verification]\n\n   **Key Learnings Validated:**\n   - [Learning with file:line reference] - [Still valid/Changed]\n   - [Pattern discovered] - [Still applicable/Modified]\n\n   **Recent Changes Status:**\n   - [Change 1] - [Verified present/Missing/Modified]\n   - [Change 2] - [Verified present/Missing/Modified]\n\n   **Artifacts Reviewed:**\n   - [Document 1]: [Key takeaway]\n   - [Document 2]: [Key takeaway]\n\n   **Recommended Next Actions:**\n   Based on the handoff's action items and current state:\n   1. [Most logical next step based on handoff]\n   2. [Second priority action]\n   3. [Additional tasks discovered]\n\n   **Potential Issues Identified:**\n   - [Any conflicts or regressions found]\n   - [Missing dependencies or broken code]\n\n   Shall I proceed with [recommended action 1], or would you like to adjust the approach?\n   ```\n\n2. **Get confirmation** before proceeding\n\n### Step 3: Create Action Plan\n\n1. **Use TodoWrite to create task list**:\n   - Convert action items from handoff into todos\n   - Add any new tasks discovered during analysis\n   - Prioritize based on dependencies and handoff guidance\n\n2. **Present the plan**:\n   ```\n   I've created a task list based on the handoff and current analysis:\n\n   [Show todo list]\n\n   Ready to begin with the first task: [task description]?\n   ```\n\n### Step 4: Begin Implementation\n\n1. **Start with the first approved task**\n2. **Reference learnings from handoff** throughout implementation\n3. **Apply patterns and approaches documented** in the handoff\n4. **Update progress** as tasks are completed\n\n## Guidelines\n\n1. **Be Thorough in Analysis**:\n   - Read the entire handoff document first\n   - Verify ALL mentioned changes still exist\n   - Check for any regressions or conflicts\n   - Read all referenced artifacts\n\n2. **Be Interactive**:\n   - Present findings before starting work\n   - Get buy-in on the approach\n   - Allow for course corrections\n   - Adapt based on current state vs handoff state\n\n3. **Leverage Handoff Wisdom**:\n   - Pay special attention to \"Learnings\" section\n   - Apply documented patterns and approaches\n   - Avoid repeating mistakes mentioned\n   - Build on discovered solutions\n\n4. **Track Continuity**:\n   - Use TodoWrite to maintain task continuity\n   - Reference the handoff document in commits\n   - Document any deviations from original plan\n   - Consider creating a new handoff when done\n\n5. **Validate Before Acting**:\n   - Never assume handoff state matches current state\n   - Verify all file references still exist\n   - Check for breaking changes since handoff\n   - Confirm patterns are still valid\n\n## Common Scenarios\n\n### Scenario 1: Clean Continuation\n- All changes from handoff are present\n- No conflicts or regressions\n- Clear next steps in action items\n- Proceed with recommended actions\n\n### Scenario 2: Diverged Codebase\n- Some changes missing or modified\n- New related code added since handoff\n- Need to reconcile differences\n- Adapt plan based on current state\n\n### Scenario 3: Incomplete Handoff Work\n- Tasks marked as \"in_progress\" in handoff\n- Need to complete unfinished work first\n- May need to re-understand partial implementations\n- Focus on completing before new work\n\n### Scenario 4: Stale Handoff\n- Significant time has passed\n- Major refactoring has occurred\n- Original approach may no longer apply\n- Need to re-evaluate strategy\n\n## Example Interaction Flow\n\n```\nUser: /resume_handoff specification/feature/handoffs/handoff-0.md\nAssistant: Let me read and analyze that handoff document...\n\n[Reads handoff completely]\n[Spawns research tasks]\n[Waits for completion]\n[Reads identified files]\n\nI've analyzed the handoff from [date]. Here's the current situation...\n\n[Presents analysis]\n\nShall I proceed with implementing the webhook validation fix, or would you like to adjust the approach?\n\nUser: Yes, proceed with the webhook validation\nAssistant: [Creates todo list and begins implementation]\n```\n",
        "validate_plan": "---\ndescription: Validate implementation against plan, verify success criteria, identify issues\n---\n\n# Validate Plan\n\nYou are tasked with validating that an implementation plan was correctly executed, verifying all success criteria and identifying any deviations or issues.\n\n## Initial Setup\n\nWhen invoked:\n1. **Determine context** - Are you in an existing conversation or starting fresh?\n   - If existing: Review what was implemented in this session\n   - If fresh: Need to discover what was done through git and codebase analysis\n\n2. **Locate the plan**:\n   - If plan path provided, use it\n   - Otherwise, search recent commits for plan references or ask user\n\n3. **Gather implementation evidence**:\n   ```bash\n   # Check recent commits\n   git log --oneline -n 20\n   git diff HEAD~N..HEAD  # Where N covers implementation commits\n\n   # Run comprehensive checks\n   cd $(git rev-parse --show-toplevel) && make check test\n   ```\n\n## Validation Process\n\n### Step 1: Context Discovery\n\nIf starting fresh or need more context:\n\n1. **Read the implementation plan** completely\n2. **Identify what should have changed**:\n   - List all files that should be modified\n   - Note all success criteria (automated and manual)\n   - Identify key functionality to verify\n\n3. **Spawn parallel research tasks** to discover implementation:\n   ```\n   Task 1 - Verify database changes:\n   Research if migration [N] was added and schema changes match plan.\n   Check: migration files, schema version, table structure\n   Return: What was implemented vs what plan specified\n\n   Task 2 - Verify code changes:\n   Find all modified files related to [feature].\n   Compare actual changes to plan specifications.\n   Return: File-by-file comparison of planned vs actual\n\n   Task 3 - Verify test coverage:\n   Check if tests were added/modified as specified.\n   Run test commands and capture results.\n   Return: Test status and any missing coverage\n   ```\n\n### Step 2: Systematic Validation\n\nFor each phase in the plan:\n\n1. **Check completion status**:\n   - Look for checkmarks in the plan (- [x])\n   - Verify the actual code matches claimed completion\n\n2. **Run automated verification**:\n   - Execute each command from \"Automated Verification\"\n   - Document pass/fail status\n   - If failures, investigate root cause\n\n3. **Assess manual criteria**:\n   - List what needs manual testing\n   - Provide clear steps for user verification\n\n4. **Think deeply about edge cases**:\n   - Were error conditions handled?\n   - Are there missing validations?\n   - Could the implementation break existing functionality?\n\n### Step 3: Generate Validation Report\n\nCreate comprehensive validation summary:\n\n```markdown\n## Validation Report: [Plan Name]\n\n### Implementation Status\n✓ Phase 1: [Name] - Fully implemented\n✓ Phase 2: [Name] - Fully implemented\n⚠️ Phase 3: [Name] - Partially implemented (see issues)\n\n### Automated Verification Results\n✓ Build passes: `make build`\n✓ Tests pass: `make test`\n✗ Linting issues: `make lint` (3 warnings)\n\n### Code Review Findings\n\n#### Matches Plan:\n- Database migration correctly adds [table]\n- API endpoints implement specified methods\n- Error handling follows plan\n\n#### Deviations from Plan:\n- Used different variable names in [file:line]\n- Added extra validation in [file:line] (improvement)\n\n#### Potential Issues:\n- Missing index on foreign key could impact performance\n- No rollback handling in migration\n\n### Manual Testing Required:\n1. UI functionality:\n   - [ ] Verify [feature] appears correctly\n   - [ ] Test error states with invalid input\n\n2. Integration:\n   - [ ] Confirm works with existing [component]\n   - [ ] Check performance with large datasets\n\n### Recommendations:\n- Address linting warnings before merge\n- Consider adding integration test for [scenario]\n- Document new API endpoints\n```\n\n## Working with Existing Context\n\nIf you were part of the implementation:\n- Review the conversation history\n- Check your todo list for what was completed\n- Focus validation on work done in this session\n- Be honest about any shortcuts or incomplete items\n\n## Important Guidelines\n\n1. **Be thorough but practical** - Focus on what matters\n2. **Run all automated checks** - Don't skip verification commands\n3. **Document everything** - Both successes and issues\n4. **Think critically** - Question if the implementation truly solves the problem\n5. **Consider maintenance** - Will this be maintainable long-term?\n\n## Validation Checklist\n\nAlways verify:\n- [ ] All phases marked complete are actually done\n- [ ] Automated tests pass\n- [ ] Code follows existing patterns\n- [ ] No regressions introduced\n- [ ] Error handling is robust\n- [ ] Documentation updated if needed\n- [ ] Manual test steps are clear\n\n## Relationship to Other Commands\n\nRecommended workflow:\n1. `/implement_plan` - Execute the implementation\n2. `/commit` - Create atomic commits for changes\n3. `/validate_plan` - Verify implementation correctness\n4. `/describe_pr` - Generate PR description\n\nThe validation works best after commits are made, as it can analyze the git history to understand what was implemented.\n\nRemember: Good validation catches issues before they reach production. Be constructive but thorough in identifying gaps or improvements.\n",
        "context-find": "# Find Context\n\nSearch the entourage repository for discussions and tasks related to a topic.\n\n## Usage\n\n```\n/context-find <topic>\n```\n\n## Examples\n\n```\n/context-find landing page\n/context-find linear\n/context-find supabase\n```\n\n## Instructions for Claude\n\n### Step 1: Verify Access\n\n```bash\nls ../entourage/data ../entourage/tasks 2>/dev/null || echo \"ERROR: Cannot access ../entourage\"\n```\n\n### Step 2: Search Tasks\n\nSearch task files for the topic:\n\n```bash\ngrep -r -i -l \"<topic>\" ../entourage/tasks/staging/\n```\n\nFor each matching task file:\n1. Read the full file\n2. Extract: id, title, priority, status, source, project\n3. Note the source field for transcript lookup\n\n### Step 3: Search Transcripts\n\nSearch all transcripts:\n\n```bash\ngrep -r -i -l \"<topic>\" ../entourage/data/\n```\n\nFor each matching transcript:\n1. Get relevant excerpts (5 lines context around match):\n   ```bash\n   grep -i -B5 -A5 \"<topic>\" <file>\n   ```\n2. Identify the source label from path\n\n### Step 4: Search Plans\n\nCheck for related implementation plans:\n\n```bash\ngrep -r -i -l \"<topic>\" ../entourage/thoughts/\n```\n\n### Step 5: Format Output\n\nPresent results in this structure:\n\n```\n## Context for \"<topic>\"\n\n### Related Tasks\n| ID | Title | Priority | Status | Project |\n|----|-------|----------|--------|---------|\n| task-20251223-2 | Build web UI | high | todo | mvp |\n\n### Discussions\n\n**granola-2025-12-23** (remote meeting):\n> [Relevant excerpt about the topic]\n> [With speaker context]\n\n**in-person-2025-12-21** (in-person):\n> [Another relevant excerpt]\n\n### Implementation Plans\n- `thoughts/plans/2025-12-22-landing-page-prd.md`\n\n### Source Files\n- Tasks: `../entourage/tasks/staging/task-20251223-2.md`\n- Transcript: `../entourage/data/remote-meeting-transcripts/granola/2025-12-23T01_50_00Z.md`\n\n---\n\n### Suggested Actions (requires approval)\n\nBased on this context, I could:\n1. [ ] Mark task-20251223-2 as \"in_progress\" (you're working on web UI)\n2. [ ] Add note to task about Supabase integration requirement\n\n**Proceed with any of these? Reply with numbers to approve, or 'skip' to continue without changes.**\n```\n\n## Notes\n\n- Always provide file paths so user can read full context\n- If no matches found, say so clearly\n- For large result sets, summarize and offer to show more\n\n## Human-in-the-Loop\n\n**CRITICAL**: After presenting context, if any action is proposed:\n\n1. **Never auto-modify** plans, tasks, or code based on findings\n2. **Always present** what was found and what could be done\n3. **Ask for approval** before:\n   - Updating task status in entourage repo\n   - Modifying implementation plans\n   - Making code changes based on context\n   - Adding new tasks\n\n**Approval format**:\n```\nBased on this context, I could:\n1. Update task-20251223-2 status to \"in_progress\"\n2. Add implementation notes from the discussion\n\nProceed with these changes? [Y/n/select specific]\n```\n\nIf user approves:\n- Make the changes\n- Report what was modified\n\nIf user declines or wants changes:\n- Wait for specific instructions\n- Do not proceed with modifications\n"
      },
      "mcp_servers": []
    }
  },
  "end": {
    "timestamp": "2025-12-26T05:22:00Z",
    "reason": "clear",
    "duration_seconds": 482,
    "git": {
      "sha": "536e35687521e1e3803bb447204389d8c98949e1",
      "dirty": true,
      "commits_made": [
        "536e35687521e1e3803bb447204389d8c98949e1",
        "c5c62a1ab4cd85d3ec64c1d9d6261a118e770fb5",
        "07d0784e570f6f35eddbc22ea4a0bbe0789e037d",
        "4703c85120adff435af520a812aa0e36f0e0eecb",
        "07e6b339700bcb0eddce63a7067740be2ae1362e",
        "ccd56e2fac05a15e23b088d6fabed528fa72f497",
        "82ab8c9250ea086a8bd88d29c690acdfd2538d34",
        "9006bff87b73c6c876328fb717c383b210e1e889",
        "d97fef894c7b4f10ed25fb9a1edae609d260b955"
      ]
    }
  }
}
